/// @file Color+Hex.swift
/// @brief Extension to create SwiftUI Color from hex strings
/// @author BlackboxPlayer Development Team
/// @details SwiftUI의 Color 타입을 확장하여 Hex 문자열로부터 색상을 생성하는 기능을 추가합니다.
///
/// 📚 이 파일의 목적
/// ════════════════════════════════════════════════════════════════════════════════
/// SwiftUI의 Color 타입을 확장(Extension)하여 Hex 문자열로부터 색상을 생성하는
/// 기능을 추가합니다.
///
/// 원래 SwiftUI Color는 hex 문자열을 직접 받아들이지 못하지만, 이 Extension을
/// 통해 "#FF0000" 같은 웹 표준 색상 코드를 사용할 수 있게 됩니다.
///
///
/// 🎨 Hex 색상 코드란?
/// ════════════════════════════════════════════════════════════════════════════════
/// Hex(16진수) 색상 코드는 웹과 디자인 도구에서 널리 사용되는 색상 표현 방식입니다.
///
/// 📌 지원하는 형식:
///
///    1) 3자리 RGB (#RGB)
///       예: "#F00" → Red
///       각 자리가 0~F(0~15) 값을 가지며, 자동으로 2배 확장됩니다.
///       #F00 → #FF0000
///
///    2) 6자리 RGB (#RRGGBB)
///       예: "#FF0000" → Red
///       각 색상 채널(R, G, B)이 00~FF(0~255) 범위를 가집니다.
///       가장 일반적으로 사용되는 형식입니다.
///
///    3) 8자리 ARGB (#AARRGGBB)
///       예: "#80FF0000" → 반투명 Red (50% 투명도)
///       맨 앞 2자리가 알파(투명도) 채널입니다.
///       AA=255(불투명), 00=0(완전 투명)
///
///
/// 🔧 Extension이란?
/// ════════════════════════════════════════════════════════════════════════════════
/// Extension은 Swift의 강력한 기능으로, 기존 타입에 새로운 기능을 추가할 수 있습니다.
///
/// 📌 특징:
///    • 원본 코드 수정 없이 기능 추가 가능
///    • SwiftUI의 Color는 Apple이 만든 타입이지만, 우리가 기능을 추가할 수 있음
///    • 프로토콜 채택, 메서드 추가, 편의 생성자 추가 등이 가능
///
/// 📌 왜 Extension을 사용하나요?
///    1) 코드 조직화: 관련 기능을 한 곳에 모을 수 있음
///    2) 재사용성: 프로젝트 전체에서 Color(hex: "#FF0000") 형태로 사용 가능
///    3) 가독성: 색상 정의가 명확해짐
///
///
/// 🎓 비트 연산 개념 (초보자용 설명)
/// ════════════════════════════════════════════════════════════════════════════════
/// 이 코드는 비트 연산을 사용하여 hex 문자열을 색상 값으로 변환합니다.
///
/// 📌 기본 개념:
///    컴퓨터는 모든 숫자를 2진수(0과 1)로 저장합니다.
///    Hex(16진수)는 2진수를 사람이 읽기 쉽게 표현한 것입니다.
///
///    예: 0xFF = 11111111 (2진수) = 255 (10진수)
///
/// 📌 사용되는 비트 연산자:
///
///    1) >> (Right Shift, 우측 시프트)
///       비트를 오른쪽으로 이동시킵니다.
///       예: 0xFF00 >> 8 = 0x00FF
///          11111111 00000000 → 00000000 11111111
///
///       💡 의미: 8비트 오른쪽으로 이동 = 256으로 나누기와 같음
///
///    2) & (Bitwise AND, 비트 논리곱)
///       두 비트가 모두 1일 때만 1을 반환합니다.
///       예: 0xFF00 & 0x00FF = 0x0000
///          11111111 00000000
///        & 00000000 11111111
///        = 00000000 00000000
///
///       💡 의미: 마스킹(특정 비트만 추출)에 사용
///
/// 📌 실전 예제:
///    hex = "FF0000" (빨간색)
///    int = 0xFF0000 (16진수로 파싱된 값)
///
///    빨강 추출: int >> 16 = 0xFF0000 >> 16 = 0xFF (255)
///    초록 추출: (int >> 8) & 0xFF = 0x00FF00 >> 8 = 0x00FF, 0x00FF & 0xFF = 0x00
///    파랑 추출: int & 0xFF = 0xFF0000 & 0xFF = 0x00
///
///
/// 💡 sRGB 색공간이란?
/// ════════════════════════════════════════════════════════════════════════════════
/// sRGB는 표준 RGB(standard RGB) 색공간으로, 대부분의 디스플레이와 웹에서
/// 사용하는 색상 표준입니다.
///
/// 📌 색공간(Color Space)이란?
///    색상을 표현하는 방법과 범위를 정의한 것입니다.
///    같은 RGB 값이라도 색공간에 따라 실제 보이는 색이 다를 수 있습니다.
///
/// 📌 sRGB의 특징:
///    • 웹 표준 색공간
///    • 대부분의 모니터가 지원
///    • RGB 각 채널이 0.0~1.0 범위의 Double 값 사용
///    • 우리가 hex에서 추출한 0~255 값을 255로 나눠 0.0~1.0으로 정규화
///
///
/// 📖 사용 예제
/// ════════════════════════════════════════════════════════════════════════════════
/// ```swift
/// // 1. 6자리 hex 색상 사용 (가장 일반적)
/// let red = Color(hex: "#FF0000")
/// let green = Color(hex: "00FF00")  // # 기호 생략 가능
/// let blue = Color(hex: "#0000FF")
///
/// // 2. 3자리 약식 표기
/// let white = Color(hex: "#FFF")  // #FFFFFF와 동일
/// let black = Color(hex: "#000")  // #000000과 동일
///
/// // 3. 8자리 ARGB (투명도 포함)
/// let transparentRed = Color(hex: "#80FF0000")  // 50% 투명한 빨강
/// let opaqueBlue = Color(hex: "#FF0000FF")      // 100% 불투명 파랑
///
/// // 4. SwiftUI 뷰에서 사용
/// Text("안녕하세요")
///     .foregroundColor(Color(hex: "#FF6B6B"))
///     .background(Color(hex: "#F0F0F0"))
///
/// // 5. EventType의 색상 표시 (실제 프로젝트 사용 예)
/// Rectangle()
///     .fill(Color(hex: eventType.colorHex))
///     .frame(width: 20, height: 20)
/// ```

import SwiftUI

// MARK: - Color Extension

/// @extension Color
/// @brief Hex 문자열로부터 SwiftUI Color를 생성하는 Extension
/// @details 3자리(#RGB), 6자리(#RRGGBB), 8자리(#AARRGGBB) Hex 형식을 지원하며,
///          비트 연산을 통해 각 색상 채널을 추출하여 sRGB 색공간의 Color 객체를 생성합니다.
extension Color {

    // MARK: Hex String Initializer

    /// @brief Create a Color from a hex string
    /// @details Hex 문자열로부터 SwiftUI Color 객체를 생성합니다.
    ///
    /// 📌 초보자를 위한 생성자(Initializer) 설명
    /// ─────────────────────────────────────────────────────────────────
    /// Initializer는 struct나 class의 인스턴스를 생성할 때 호출되는 특수한 메서드입니다.
    /// `init` 키워드로 정의하며, 반환 타입을 명시하지 않습니다.
    ///
    /// 이 생성자는 String 타입의 hex 파라미터를 받아서 Color 인스턴스를 만듭니다.
    /// 사용 예: let red = Color(hex: "#FF0000")
    ///
    ///
    /// 🔄 전체 동작 흐름
    /// ─────────────────────────────────────────────────────────────────
    /// 1단계: 입력 문자열 정제 (trimming)
    /// 2단계: Hex 문자열을 64비트 정수로 파싱
    /// 3단계: 색상 채널(A, R, G, B) 추출 (비트 연산 사용)
    /// 4단계: 0~255 값을 0.0~1.0 범위로 정규화
    /// 5단계: sRGB 색공간을 사용하는 Color 객체 생성
    ///
    /// @param hex Hex color string (e.g., "#FF0000", "FF0000", "#F00")
    ///            지원 형식: 3자리(#RGB), 6자리(#RRGGBB), 8자리(#AARRGGBB)
    init(hex: String) {
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 1단계: 입력 문자열 정제
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        //
        // 📌 목적:
        //    사용자가 "#FF0000", "FF0000", "#ff0000" 등 다양한 형태로 입력해도
        //    올바르게 처리할 수 있도록 문자열을 정제합니다.
        //
        // 📌 동작 설명:
        //    trimmingCharacters(in:) 메서드는 지정된 문자 집합에 속하지 않는
        //    문자들을 제거합니다.
        //
        //    CharacterSet.alphanumerics는 영문자(a-z, A-Z)와 숫자(0-9)를 포함하는
        //    문자 집합입니다.
        //
        //    .inverted는 이를 반전시켜서 "영문자와 숫자가 아닌 것들"을 의미합니다.
        //    즉, #, 공백, 특수문자 등이 모두 제거됩니다.
        //
        // 📌 예시:
        //    입력: "#FF0000"  → 정제 후: "FF0000"
        //    입력: "FF 00 00" → 정제 후: "FF0000"
        //    입력: "#ff0000"  → 정제 후: "ff0000" (소문자도 허용)
        //
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 2단계: Hex 문자열을 정수로 변환
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        //
        // 📌 UInt64 타입 선택 이유:
        //    UInt64는 부호 없는(음수가 없는) 64비트 정수입니다.
        //    0 ~ 18,446,744,073,709,551,615 범위의 값을 저장할 수 있습니다.
        //
        //    8자리 hex (#AARRGGBB)는 최대 0xFFFFFFFF (4,294,967,295)이므로
        //    UInt64면 충분히 안전하게 저장할 수 있습니다.
        //
        // 📌 초기값 0:
        //    변수 선언 시 반드시 초기값을 지정해야 합니다.
        //    Scanner가 파싱에 실패하면 int는 0으로 유지됩니다.
        //
        var int: UInt64 = 0

        // 📌 Scanner란?
        //    Foundation 프레임워크의 클래스로, 문자열을 파싱하는 도구입니다.
        //    scanHexInt64(_:)는 16진수 문자열을 UInt64로 변환합니다.
        //
        // 📌 & 연산자의 의미:
        //    Swift에서 &는 inout 파라미터를 전달할 때 사용합니다.
        //    inout은 함수 내부에서 파라미터를 수정하면, 원본 변수도 변경되는 것을 의미합니다.
        //
        //    scanHexInt64는 변환된 값을 int 변수에 직접 저장합니다.
        //
        // 📌 예시:
        //    hex = "FF0000"
        //    → Scanner가 이를 파싱
        //    → int = 0xFF0000 = 16,711,680 (10진수)
        //
        Scanner(string: hex).scanHexInt64(&int)

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 3단계: 색상 채널 추출 (비트 연산)
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        //
        // 📌 변수 선언 방식:
        //    let a, r, g, b: UInt64
        //    이는 4개의 변수를 한 번에 선언하는 문법입니다.
        //    모두 UInt64 타입이며, 아직 값이 할당되지 않았습니다.
        //
        // 📌 왜 let을 사용하나요?
        //    a, r, g, b 값은 한 번 설정되면 변경되지 않으므로 상수(let)로 선언합니다.
        //    불변성(Immutability)을 보장하여 실수로 값을 변경하는 것을 방지합니다.
        //
        let a, r, g, b: UInt64

        // 📌 switch 문으로 hex 길이 분류:
        //    hex 문자열의 길이에 따라 다른 파싱 로직을 적용합니다.
        //
        switch hex.count {

        // ─────────────────────────────────────────────────────────────────
        // Case 1: 3자리 RGB (#RGB)
        // ─────────────────────────────────────────────────────────────────
        //
        // 📌 형식 예시: "#F0A" → #FF00AA
        //
        // 📌 변환 원리:
        //    각 hex 자리(0~F)를 2배 확장합니다.
        //    F(15) → FF(255)
        //    0(0)  → 00(0)
        //    A(10) → AA(170)
        //
        // 📌 비트 구조:
        //    int = 0x0RGB (12비트만 사용)
        //    예: 0xF0A = 0000 1111 0000 1010
        //
        // 📌 각 채널 추출 과정:
        //
        //    1) 알파(투명도): 항상 255 (완전 불투명)
        //       a = 255
        //
        //    2) 빨강(Red): 상위 8비트 추출 후 17 곱하기
        //       int >> 8 = 0xF0A >> 8 = 0x00F (0000 0000 0000 1111)
        //       0x00F * 17 = 15 * 17 = 255
        //
        //       💡 왜 17을 곱하나요?
        //       한 자리 hex(0~F)를 두 자리(00~FF)로 확장하는 공식:
        //       value * 17 = value * 16 + value = value << 4 | value
        //       예: F * 17 = 15 * 17 = 255 = 0xFF
        //
        //    3) 초록(Green): 중간 4비트 추출 후 17 곱하기
        //       (int >> 4) & 0xF = (0xF0A >> 4) & 0xF
        //                        = 0x0F0 & 0x00F
        //                        = 0x000 (0)
        //       0x000 * 17 = 0
        //
        //    4) 파랑(Blue): 하위 4비트 추출 후 17 곱하기
        //       int & 0xF = 0xF0A & 0x00F = 0x00A (10)
        //       0x00A * 17 = 10 * 17 = 170
        //
        // 📌 최종 결과:
        //    #F0A → RGBA(255, 0, 170, 255) = 불투명한 분홍색
        //
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)

        // ─────────────────────────────────────────────────────────────────
        // Case 2: 6자리 RGB (#RRGGBB) - 가장 일반적
        // ─────────────────────────────────────────────────────────────────
        //
        // 📌 형식 예시: "#FF0000" → 빨간색
        //
        // 📌 비트 구조:
        //    int = 0xRRGGBB (24비트)
        //    예: 0xFF0000 = 11111111 00000000 00000000
        //
        // 📌 각 채널 추출 과정:
        //
        //    1) 알파: 항상 255 (완전 불투명)
        //       a = 255
        //
        //    2) 빨강: 상위 16비트 시프트
        //       int >> 16 = 0xFF0000 >> 16 = 0x0000FF (255)
        //
        //       비트로 표현:
        //       11111111 00000000 00000000 >> 16
        //       = 00000000 00000000 11111111
        //
        //    3) 초록: 중간 8비트 추출
        //       (int >> 8) & 0xFF = (0xFF0000 >> 8) & 0xFF
        //                         = 0x00FF00 & 0x0000FF
        //                         = 0x000000 (0)
        //
        //       비트로 표현:
        //       11111111 00000000 00000000 >> 8
        //       = 00000000 11111111 00000000
        //       & 00000000 00000000 11111111
        //       = 00000000 00000000 00000000
        //
        //    4) 파랑: 하위 8비트 추출
        //       int & 0xFF = 0xFF0000 & 0x0000FF = 0x000000 (0)
        //
        //       비트로 표현:
        //       11111111 00000000 00000000
        //       & 00000000 00000000 11111111
        //       = 00000000 00000000 00000000
        //
        // 📌 최종 결과:
        //    #FF0000 → RGBA(255, 0, 0, 255) = 불투명한 빨간색
        //
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)

        // ─────────────────────────────────────────────────────────────────
        // Case 3: 8자리 ARGB (#AARRGGBB)
        // ─────────────────────────────────────────────────────────────────
        //
        // 📌 형식 예시: "#80FF0000" → 50% 투명한 빨간색
        //
        // 📌 비트 구조:
        //    int = 0xAARRGGBB (32비트)
        //    예: 0x80FF0000 = 10000000 11111111 00000000 00000000
        //
        // 📌 각 채널 추출 과정:
        //
        //    1) 알파: 최상위 8비트
        //       int >> 24 = 0x80FF0000 >> 24 = 0x00000080 (128)
        //
        //       비트로 표현:
        //       10000000 11111111 00000000 00000000 >> 24
        //       = 00000000 00000000 00000000 10000000
        //
        //       💡 알파 값의 의미:
        //       0 = 완전 투명 (invisible)
        //       128 = 50% 투명 (semi-transparent)
        //       255 = 완전 불투명 (opaque)
        //
        //    2) 빨강: 상위 16비트 시프트 후 마스킹
        //       (int >> 16) & 0xFF = (0x80FF0000 >> 16) & 0xFF
        //                          = 0x000080FF & 0x000000FF
        //                          = 0x000000FF (255)
        //
        //    3) 초록: 상위 8비트 시프트 후 마스킹
        //       (int >> 8) & 0xFF = (0x80FF0000 >> 8) & 0xFF
        //                         = 0x0080FF00 & 0x000000FF
        //                         = 0x00000000 (0)
        //
        //    4) 파랑: 하위 8비트 추출
        //       int & 0xFF = 0x80FF0000 & 0x000000FF = 0x00000000 (0)
        //
        // 📌 최종 결과:
        //    #80FF0000 → RGBA(255, 0, 0, 128) = 50% 투명한 빨간색
        //
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)

        // ─────────────────────────────────────────────────────────────────
        // Case 4: 잘못된 형식 처리
        // ─────────────────────────────────────────────────────────────────
        //
        // 📌 발생 조건:
        //    hex 길이가 3, 6, 8이 아닌 경우 (예: 1, 2, 4, 5, 7, 9+ 자리)
        //
        // 📌 기본값:
        //    검은색(R=0, G=0, B=0)을 반환하되, 완전 불투명(A=255)으로 설정
        //
        // 📌 에러 처리 전략:
        //    Swift에서는 throw로 에러를 던질 수도 있지만, 이 경우 사용성을 위해
        //    안전한 기본값을 반환하는 방식을 선택했습니다.
        //
        //    장점: Color(hex: "invalid") 같은 잘못된 입력도 크래시 없이 처리
        //    단점: 개발자가 오타를 눈치채기 어려울 수 있음
        //
        // 📌 대안적 설계:
        //    Optional Color를 반환하거나(init?(hex: String))
        //    에러를 throw할 수도 있지만, 현재 설계는 편의성을 우선합니다.
        //
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 4~5단계: sRGB Color 객체 생성
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        //
        // 📌 정규화(Normalization)란?
        //    0~255 범위의 정수를 0.0~1.0 범위의 실수로 변환하는 과정입니다.
        //
        //    SwiftUI Color는 색상 채널 값을 0.0~1.0 범위로 받습니다.
        //    따라서 255로 나누어 변환합니다:
        //    • 0 ÷ 255 = 0.0 (최소값)
        //    • 128 ÷ 255 ≈ 0.502 (중간값)
        //    • 255 ÷ 255 = 1.0 (최대값)
        //
        // 📌 Double 타입 변환:
        //    UInt64를 Double로 변환해야 나눗셈 결과가 실수가 됩니다.
        //    정수 나눗셈은 소수점 이하를 버리기 때문입니다.
        //
        //    예: Int(255) / Int(255) = 1 (정수)
        //        Double(255) / 255.0 = 1.0 (실수)
        //
        // 📌 .sRGB 색공간:
        //    Color의 첫 번째 파라미터는 RGBColorSpace입니다.
        //    .sRGB는 표준 RGB 색공간으로, 웹과 대부분의 디스플레이에서 사용됩니다.
        //
        //    다른 색공간:
        //    • .sRGBLinear: 감마 보정이 없는 선형 RGB
        //    • .displayP3: 더 넓은 색영역을 지원 (최신 Apple 기기)
        //
        // 📌 self.init의 의미:
        //    Extension 내에서 원래 타입의 다른 생성자를 호출합니다.
        //    self는 "현재 생성 중인 인스턴스"를 의미합니다.
        //
        //    SwiftUI Color는 다음과 같은 기본 생성자를 제공합니다:
        //    init(_ colorSpace: RGBColorSpace,
        //         red: Double,
        //         green: Double,
        //         blue: Double,
        //         opacity: Double)
        //
        // 📌 실제 변환 예시:
        //    r = 255, g = 0, b = 0, a = 128 (빨간색, 50% 투명)
        //    → red: 255/255 = 1.0
        //      green: 0/255 = 0.0
        //      blue: 0/255 = 0.0
        //      opacity: 128/255 ≈ 0.502
        //
        //    결과: 50% 투명한 빨간색 Color 객체
        //
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}
