/** * @file SyncControllerTests.swift * @brief Unit Tests and Integration Tests for SyncController class * @author BlackboxPlayer Team * * @details * * @section sync_overview SyncController Overview * * A central control component that synchronizes and plays multiple VideoChannels. * * @subsection sync_structure Multi-Channel Synchronization Structure * * @endcode * SyncController (central controller) * ├── VideoChannel (front) ──→ frame @ 3.500seconds * ├── VideoChannel (rear) ──→ frame @ 3.502seconds * ├── VideoChannel (side) ──→ frame @ 3.498seconds * ├── GPSService ──→ GPS data * └── GSensorService ──→ G-Sensor data * ↓ * Time Synchronization (± 50ms within) * ↓ * Display on screen: all channels 3.5seconds frame * @endcode * * @subsection sync_features Key Features * * -# <b>Channel Management</b>: Load and manage multiple video channels * -# <b>Playback Control</b>: play, pause, stop, seek * -# <b>Time Synchronization</b>: Align all channels to the same timestamp * -# <b>Speed Control</b>: 0.5x ~ 2.0x playback speed control * -# <b>Sensor Services</b>: Manage GPS and G-sensor data * * @subsection test_scope Test Scope * * - Initialization and state management * - Playback Control (play, pause, stop, seek) * - channel synchronization * - time formatting * - Thread safety * - Memory management * - Performance measurement */ // ============================================================================ // MARK: - Imports // ============================================================================ /** * @brief Apple frame * * @details * XCTestCase inherit create a class, * XCTAssert with functions Verify perform. */ import XCTest /** * @brief Apple Reactive Programming frame * * @details * used in this test Combine functionality: * * @endcode * // 1. @Published property subscribe: * syncController.$playbackState *.sink { state in... } * * // 2. value: * syncController.$currentTime *.sink { time in... } * * // 3. AnyCancellable subscribe: *.store(in: &cancellables) * @endcode */ import Combine /** * @brief Test target module import * * @details * @testable when attached internal access modifiers can be used. * * @note access control levels: * @endcode * open > public > internal > fileprivate > private * ↑ ↑ * can subclass @testable can access * @endcode */ @testable import BlackboxPlayer // ============================================================================ // MARK: - SyncControllerTests (Unit Tests) // ============================================================================ /** * @class SyncControllerTests * @brief SyncController basic behavior Verify Unit Test * * @details * SyncController each methodand property independently. * * @section unit_vs_integration Unit Tests vs Integration Tests * * <b>Unit Tests (this class):</b> * - without channels standalone * - fast * - method Verify * - Mock data use * * <b>Integration Tests (SyncControllerIntegrationTests):</b> * - actual file load * - entire * - * - actual data use * * @section test_targets Test target * * - initial state Verify * - * - Playback Control method * - Seeking * - time formatting * - Thread safety * - Memory management * * @note final * inherit final. * @endcode * final class SyncControllerTests // ✅ * class SyncControllerTests // ❌ can subclass * @endcode */ final class SyncControllerTests: XCTestCase { // ======================================================================== // MARK: - Properties // ======================================================================== /** * @var syncController * @brief Test target SyncController instance * * @details * each method setUp() create. * * @note Implicitly Unwrapped Optional (!) use * * <b>:</b> * - setUp() initialization * - * - * * @endcode * // and: * setUp() → syncController = SyncController() * → syncController.play() // * tearDown() → syncController = nil * @endcode */ var syncController: SyncController! /** * @var cancellables * @brief Combine subscribe(subscription) * * @details * @Published property subscribe create AnyCancellable object * Set. * * @note Combine subscribe lifecycle * @endcode * // 1. subscribe create * syncController.$playbackState *.sink { state in * print("State: \(state)") * } *.store(in: &cancellables) // 2. Set * * // 3. tearDown() cancellables = nil * // → Set subscribealso * @endcode * * @par Set use? * - AnyCancellable Hashable * - Set subscribe * - subscribe cleanup */ var cancellables: Set<AnyCancellable>! // ======================================================================== // MARK: - Setup & Teardown // ======================================================================== /** * @brief each method setUp method * * @details * each method ****. * * @par: * @endcode * 1. setUp() * ├─ super.setUp() * ├─ continueAfterFailure = false * ├─ syncController create * └─ cancellables initialization * 2. testInitialState() * 3. tearDown() * ↓ * 4. setUp() ( instance) * 5. testPlaybackStatePublishing() * 6. tearDown() *... (each) * @endcode * * @warning continueAfterFailure = false * @endcode * // false (value): * XCTAssertEqual(a, 1) // ❌ failure * XCTAssertEqual(b, 2) // ⏹️ () * * // true: * XCTAssertEqual(a, 1) // ❌ failure * XCTAssertEqual(b, 2) // ✅ * @endcode * * @throws XCTest error */ override func setUpWithError() throws { // setUp super.setUp() // failure ( fast) continueAfterFailure = false // Test target SyncController create syncController = SyncController() // Combine subscribe initialization cancellables = [] } /** * @brief each method tearDown method * * @details * each method ****. * * @par cleanup(cleanup) Tasks: * @endcode * A: * setUp() → syncController create * → syncController load * tearDown() → syncController.stop() + nil * * B: * setUp() → syncController create * → ✅ * @endcode * * @warning * @endcode * syncController.stop() // 1. * syncController = nil // 2. (ARC) * cancellables = nil // 3. subscribe * @endcode * * @par: * @endcode * 1. method complete * 2. tearDown() * ├─ syncController.stop() // * ├─ syncController = nil // instance * ├─ cancellables = nil // subscribe * └─ super.tearDown() // cleanup * @endcode * * @throws XCTest error */ override func tearDownWithError() throws { // SyncController cleanup syncController.stop() // (ARC) syncController = nil // Combine subscribe cancellables = nil // tearDown super.tearDown() } // ======================================================================== // MARK: - Initialization Tests // ======================================================================== /** * @name Initialization Tests * @{ * * @test testInitialState * @brief SyncController initial state Verify * * @details * SyncController create property value * initialization Verify. * * @par Verify: * <b>:</b> * - playbackState:.stopped () * - channelCount: 0 (load) * - allChannelsReady: false () * * <b>:</b> * - currentTime: 0.0 () * - playbackPosition: 0.0 ( 0~1) * - duration: 0.0 () * * <b>:</b> * - playbackSpeed: 1.0 ( also) * * @note initial state? * @endcode * // initialization: * playbackState =.playing // ❌? * currentTime = 100.0 // ❌ 100seconds? * * // initialization: * playbackState =.stopped // ✅ * currentTime = 0.0 // ✅ * @endcode * * @par Given-When-Then: * - <b>Given:</b> setUp() SyncController create * - <b>When:</b> () - also * - <b>Then:</b> secondsvalue */ func testInitialState() { // Then: initial state Verify // 🎮.stopped XCTAssertEqual( syncController.playbackState,.stopped, "Initial state should be stopped") // ⏱️ 0seconds XCTAssertEqual( syncController.currentTime, 0.0, "Initial time should be 0") // 📍 0.0 (0%) XCTAssertEqual( syncController.playbackPosition, 0.0, "Initial position should be 0") // ⚡ also 1.0x ( also) XCTAssertEqual( syncController.playbackSpeed, 1.0, "Initial speed should be 1.0") // ⏲️ 0seconds () XCTAssertEqual( syncController.duration, 0.0, "Initial duration should be 0") // 📺 load 0 XCTAssertEqual( syncController.channelCount, 0, "Initial channel count should be 0") // ❌ () XCTAssertFalse( syncController.allChannelsReady, "Channels should not be ready initially") } /** * @test testServicesInitialization * @brief Sensor Services initialization Verify * * @details * ✅: Sensor Services initialization * ──────────────────────────────────────────────────────────────────── * SyncController GPSand G-Sensor normally initialization * Verify. * * @section sensor_service 🌐 Sensor Services? * @endcode * SyncController * ├── GPSService * │ ├─ also/also data * │ ├─ also information * │ └─ also data * │ * └── GSensorService * ├─ X also * ├─ Y also * └─ Z also () * @endcode * * @note 💡: * @endcode * GPS data:, path * G-Sensor:, / * @endcode * * @par Given-When-Then: * - <b>Given:</b> setUp() SyncController create * - <b>When:</b> () - also * - <b>Then:</b> gpsServiceand gsensorService nil * * @warning ⚠️ XCTAssertNotNil vs XCTAssertEqual: * @endcode * XCTAssertNotNil(service) // ✅ Confirm * XCTAssertEqual(service, expectedService) // value * @endcode */ func testServicesInitialization() { // Then: initialization Verify // 🌐 GPS initialization XCTAssertNotNil( syncController.gpsService, "GPS service should be initialized") // 📡 G-Sensor initialization XCTAssertNotNil( syncController.gsensorService, "G-Sensor service should be initialized") } // ======================================================================== // MARK: - State Management Tests // ======================================================================== // // 🎯 Purpose: and Combine Verify. // // ✅ Verify: // - // - @Published property value // - Combine subscribe /** * @test testPlaybackStateTransitions * @brief Verify * * @details * ✅: * ──────────────────────────────────────────────────────────────────── * SyncController seconds.stopped Confirm. * * @section playback_flow 🔄 PlaybackState: * @endcode *.stopped ──loadVideo──→.paused ──play()──→.playing * ↑ ↑ ↓ * └────── stop() ──────────┴────── pause() ────┘ * @endcode * * @note 💡 Unit Test: * @endcode * Unit Test (): * - without channels initial state Confirm * - fast * * Integration Test (): * - actual load entire * -.stopped →.paused →.playing Verify * @endcode * * @par Given-When-Then: * - <b>Given:</b> setUp() SyncController create * - <b>When:</b> () - also * - <b>Then:</b> playbackState.stopped */ func testPlaybackStateTransitions() { // Given: Controller starts in.stopped state // 🎮 initial state.stopped XCTAssertEqual(syncController.playbackState,.stopped) // 📝 Note: Actual state transitions require loaded channels // This is tested in integration tests // // 💡 actual load. // entire Integration Tests Verify. } /** * * @section _______________ ✅: * ──────────────────────────────────────────────────────────────────── * @Published playbackState property Combine * value normally Verify. * * * @section combine________ 🔄 Combine * @endcode * @Published var playbackState: PlaybackState =.stopped * ↓ * Publisher create * ↓ * syncController.$playbackState // $ when attached Publisher * ↓ *.sink { state in } // subscribe (subscribe) * ↓ * value * @endcode * * * @section xctestexpectation___ 💡 XCTestExpectation? * @endcode * let expectation = expectation(description: "...") * * // Tasks (Combine subscribe) *.sink { value in * expectation.fulfill() // ✅ complete * } * * wait(for: [expectation], timeout: 1.0) // ⏱️ 1seconds * @endcode * * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> playbackState subscribe * - <b>When:</b> subscribe (secondsvalue) * - <b>Then:</b> value.stopped * @endcode * * @test testPlaybackStatePublishing * @brief ⚠️ timeout? * * @details * * @section __timeout________ ⚠️ timeout? * @endcode *: 0.01seconds value → and *: value → 1seconds failure () * @endcode */ func testPlaybackStatePublishing() { // Given: subscribe // 🎯 Tasks complete Expectation create let expectation = expectation(description: "Playback state published") // 📦 array var receivedStates: [PlaybackState] = [] // 🔄 @Published playbackState subscribe syncController.$playbackState.sink { state in // 💡.sink: // - value // - secondsvaluealso (.stopped) // receivedStates.append(state) // 1 expectation complete (multiple fulfill) if receivedStates.count == 1 { expectation.fulfill() } }.store(in: &cancellables) // ⚠️.store(in:): // → subscribe () // → value // Then: value Verify // ⏱️ expectation fulfill 1seconds wait(for: [expectation], timeout: 1.0) // 📝 value.stopped XCTAssertEqual(receivedStates.first,.stopped) } /** * * @section _______________ ✅: * ──────────────────────────────────────────────────────────────────── * @Published currentTime property Combine * value normally Verify. * * ⏱️ currentTime: * @endcode * SyncController * ├── currentTime: 3.5seconds () * ├── duration: 60.0seconds (entire) * └── playbackPosition: 0.058 (3.5 / 60.0) * * UI: * currentTime → Combine → UI * @endcode * * * @section ____________ 🔄 * @endcode *: 0.0seconds → 0.033seconds → 0.066seconds →... (30fps) * ↓ ↓ ↓ *.sink.sink.sink * ↓ ↓ ↓ * UI () * @endcode * * * @section timeinterval___ 💡 TimeInterval? * @endcode * typealias TimeInterval = Double * * currentTime: TimeInterval = 3.5 // 3.5seconds * @endcode * * @test testCurrentTimePublishing * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> currentTime subscribe * - <b>When:</b> subscribe (secondsvalue) * - <b>Then:</b> value 0.0 * @endcode */ func testCurrentTimePublishing() { // Given: subscribe // 🎯 Tasks complete Expectation let expectation = expectation(description: "Current time published") // ⏱️ value array var receivedTimes: [TimeInterval] = [] // 🔄 @Published currentTime subscribe syncController.$currentTime.sink { time in // 💡 seconds 30 (30fps) // receivedTimes.append(time) // 1 expectation complete (multiple fulfill) if receivedTimes.count == 1 { expectation.fulfill() } }.store(in: &cancellables) // 📦 cancellables Set subscribe // Then: secondsvalue Verify // ⏱️ 1seconds wait(for: [expectation], timeout: 1.0) // ⏱️ value 0.0 (initial state) XCTAssertEqual(receivedTimes.first, 0.0) } // ======================================================================== // MARK: - Playback Control Tests // ======================================================================== // // 🎯 Purpose: Playback Control method(play, pause, stop, toggle) Verify. // // ✅ Verify: // - without channels also (failure) // - without channels also (failure) // - method () // - method ( initialization) /** * * @section ________________ ✅: without channels also * ──────────────────────────────────────────────────────────────────── * load play() *.stopped Verify. * * * @section __________ 🔄 * @endcode * 1. loadVideoFile() → load →.paused * 2. play() → →.playing * @endcode * * * @section __________________ ⚠️ () * @endcode * 1. ( load) * 2. play() → ❌ →.stopped * @endcode * * * @section __________________ 💡? * @endcode * //: * play() // → nil →! 💥 * * //: * play() // → Confirm → Return ✅ * @endcode * * @test testPlayWithoutChannels * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> load SyncController * - <b>When:</b> play() method * - <b>Then:</b> playbackState.stopped * @endcode */ func testPlayWithoutChannels() { // When: without channels also syncController.play() // Then:.stopped // ⚠️.stopped XCTAssertEqual( syncController.playbackState,.stopped, "Should remain stopped without channels") } /** * * @section __________________________ ✅: also * ──────────────────────────────────────────────────────────────────── * pause() *.stopped Verify. * * * @section ____________ 🔄 * @endcode *.playing ──pause()──→.paused * @endcode * * * @section _________ ⚠️ * @endcode *.stopped ──pause()──→.stopped () * @endcode * * * @section idempotent________ 💡 Idempotent() * @endcode * pause() also * * pause() //.stopped →.stopped * pause() //.stopped →.stopped () * @endcode * * @test testPauseWithoutPlaying * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b>.stopped SyncController * - <b>When:</b> pause() method * - <b>Then:</b> playbackState.stopped * @endcode */ func testPauseWithoutPlaying() { // When: also syncController.pause() // Then:.stopped // 💡 XCTAssertEqual( syncController.playbackState,.stopped, "Should remain stopped") } /** * * @section _______________ ✅: / * ──────────────────────────────────────────────────────────────────── * togglePlayPause() method Verify. * * * @section toggleplaypause_____ 🔄 togglePlayPause() * @endcode * if playbackState ==.playing { * pause() // → * } else { * play() // / → * } * @endcode * * * @section ui______ 💡 UI * @endcode * Button("▶️/⏸️") { * syncController.togglePlayPause() * } * // / * @endcode * * * @section unit_test____ ⚠️ Unit Test * @endcode * Unit Test: * - method Confirm * - actual * * Integration Test: * - actual load Verify * -.playing ⇄.paused Confirm * @endcode * * @test testTogglePlayPause * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> SyncController * - <b>When:</b> togglePlayPause() * - <b>Then:</b> complete * @endcode */ func testTogglePlayPause() { // Note: Requires loaded channels for actual toggle // Unit test verifies method exists and doesn't crash // // 📝 actual load. // Unit Test method and Verify. // When: method syncController.togglePlayPause() // Then: complete // 💡 syncController nil method XCTAssertNotNil(syncController) } /** * * @section ________stop____ ✅: (Stop) * ──────────────────────────────────────────────────────────────────── * stop() method initialization Verify. * * * @section stop______ 🔄 stop() * @endcode * 1. * 2..stopped * 3. property initialization * 4. Sensor Services cleanup * @endcode * * * @section stop___vs_pause______ 💡 stop() vs pause() * @endcode * pause(): * -.playing →.paused * - () * - currentTime () * - play() * * stop(): * - →.stopped * - ( cleanup) * - currentTime = 0.0 () * - loadVideoFile() * @endcode * * 🧹 cleanup Tasks: * @endcode * stop(): * ├─ playbackState =.stopped * ├─ currentTime = 0.0 * ├─ playbackPosition = 0.0 * ├─ duration = 0.0 * ├─ channelCount = 0 * └─ VideoChannel * @endcode * * @test testStop * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> SyncController instance * - <b>When:</b> stop() method * - <b>Then:</b> secondsvalue * @endcode */ func testStop() { // When: method syncController.stop() // Then: initialization // 🎮.stopped XCTAssertEqual(syncController.playbackState,.stopped) // ⏱️ 0.0 XCTAssertEqual(syncController.currentTime, 0.0) // 📍 0.0 () XCTAssertEqual(syncController.playbackPosition, 0.0) // ⏲️ also 0.0 () XCTAssertEqual(syncController.duration, 0.0) // 📺 load also 0 XCTAssertEqual(syncController.channelCount, 0) } // ======================================================================== // MARK: - Seeking Tests // ======================================================================== // // 🎯 Purpose: Seeking() functionality Verify. // // ✅ Verify: // - (seekToTime) // - (seekBySeconds) // - (value) // - (clamping) /** * * @section _______________ ✅: * ──────────────────────────────────────────────────────────────────── * seekToTime() method, * value (clamp) Verify. * * * @section seeking___ 🎬 Seeking? * @endcode *: * [========●====================] 60seconds * ↑ *: 10seconds * * seekToTime(30.0): * [==========================●==] 60seconds * ↑ *: 30seconds * @endcode * * * @section _____seeking___ 🔄 Seeking * @endcode * 1. load (duration = 60.0seconds) * 2. seekToTime(30.0) * 3. currentTime = 30.0 * 4. 30seconds * 5. * @endcode * * * @section clamping________ ⚠️ Clamping () * @endcode * // duration = 60seconds * seekToTime(-10.0) → 0.0 (value) * seekToTime(30.0) → 30.0 () * seekToTime(100.0) → 60.0 (value) * @endcode * * * @section __unit_test____ 💡 Unit Test * @endcode * duration = 0 () * seekToTime(5.0) * → 0...0 clamp * → currentTime = 0.0 * @endcode * * @test testSeekToTime * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> SyncController (duration = 0) * - <b>When:</b> seekToTime(5.0) * - <b>Then:</b> currentTime 0.0 * @endcode */ func testSeekToTime() { // Note: Requires loaded channels // Unit test verifies method exists // // 📝 actual Seeking load. // Unit Test (clamping) Verify. // When: 5.0seconds also syncController.seekToTime(5.0) // Then: Should clamp to 0.0 since duration is 0 // ⚠️ duration 0 0...0 // → 5.0 0.0 XCTAssertEqual(syncController.currentTime, 0.0) } /** * * @section ______________ ✅: * ──────────────────────────────────────────────────────────────────── * seekBySeconds() method * Verify. * * * @section seektotime_vs_seekbyseconds 🔄 seekToTime vs seekBySeconds * @endcode *: 10seconds * * seekToTime(30.0): * - * - 10seconds → 30seconds * * seekBySeconds(+20.0): * - * - 10seconds + 20seconds = 30seconds * * seekBySeconds(-5.0): * - * - 10seconds - 5seconds = 5seconds * @endcode * * * @section ui______ 💡 UI * @endcode * Button("⏪ 10seconds ") { * syncController.seekBySeconds(-10.0) * } * * Button("⏩ 10seconds ") { * syncController.seekBySeconds(+10.0) * } * @endcode * * * @section _____ 🔄 * @endcode * func seekBySeconds(_ offset: Double) { * let newTime = currentTime + offset * seekToTime(newTime) // seekToTime * } * @endcode * * * @section __unit_test____ ⚠️ Unit Test * @endcode * currentTime = 0.0 (secondsvalue) * duration = 0.0 () * * seekBySeconds(10.0) * → newTime = 0.0 + 10.0 = 10.0 * → seekToTime(10.0) * → 0...0 clamp → 0.0 * @endcode * * @test testSeekBySeconds * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> currentTime = 0, duration = 0 * - <b>When:</b> seekBySeconds(10.0) * - <b>Then:</b> currentTime 0.0 * @endcode */ func testSeekBySeconds() { // When: 10seconds also syncController.seekBySeconds(10.0) // Then: Should seek from current time // With duration 0, should clamp to 0 // 💡: // newTime = currentTime(0.0) + offset(10.0) = 10.0 // → duration 0 0.0 XCTAssertEqual(syncController.currentTime, 0.0) } /** * * @section _____________ ✅: * ──────────────────────────────────────────────────────────────────── * seekToTime() 0 Verify. * * 🔒 value (Boundary Testing): * @endcode *: 0 ≤ time ≤ duration * * value: * ├─ time < 0 ( secondsand) → 0 * ├─ time = 0 () → * ├─ time = duration () → * └─ time > duration ( secondsand) → duration * @endcode * * * @section ______________ ⚠️ * @endcode * // use: * currentTime = 3.0 * seekBySeconds(-10.0) * → newTime = 3.0 - 10.0 = -7.0 ❌ * → seekToTime(-7.0) * → 0.0 ✅ * @endcode * * * @section _________ 💡 * @endcode * //: * seekToTime(-5.0) * → videoChannel.seek(-5.0) * → FFmpeg error! 💥 * * //: * seekToTime(-5.0) * → clamp(-5.0, 0...60) = 0.0 * → videoChannel.seek(0.0) ✅ * @endcode * * @test testSeekNegativeTime * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> SyncController instance * - <b>When:</b> seekToTime(-5.0) () * - <b>Then:</b> currentTime 0.0 * @endcode */ func testSeekNegativeTime() { // When: also syncController.seekToTime(-5.0) // Then: Should clamp to 0 // 🔒 value 0.0 XCTAssertEqual(syncController.currentTime, 0.0) } // ======================================================================== // MARK: - Synchronized Frames Tests // ======================================================================== // // 🎯 Purpose: channel synchronization functionality Verify. // // ✅ Verify: // - getSynchronizedFrames() method // - getBufferStatus() method // - /** * * @section _____________________ ✅: without channels frame query * ──────────────────────────────────────────────────────────────────── * getSynchronizedFrames() empty Return * Verify. * * * @section __________ 🔄 frame? * @endcode *: * *: 3.5seconds * * front: [frame @ 3.498seconds] ─┐ * rear: [frame @ 3.502seconds] ─┼─→ * side: [frame @ 3.500seconds] ─┘ * ↓ * getSynchronizedFrames() Return: * [ *.front: VideoFrame @ 3.498seconds, *.rear: VideoFrame @ 3.502seconds, *.left: VideoFrame @ 3.500seconds * ] * @endcode * * * @section ________ 💡 * @endcode *: each frame * (,) * *: SyncController ±50ms within frame * " " Display on screen * @endcode * * * @section _____ 🔍 Return * @endcode * [CameraPosition: VideoFrame] * * //: * [ *.front: frame1, *.rear: frame2 * ] * @endcode * * * @section ________ ⚠️ * @endcode * let frames = getSynchronizedFrames() * frames.isEmpty // true * @endcode * * @test testGetSynchronizedFramesWithNoChannels * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> SyncController * - <b>When:</b> getSynchronizedFrames() * - <b>Then:</b> empty Return * @endcode */ func testGetSynchronizedFramesWithNoChannels() { // When: frame query let frames = syncController.getSynchronizedFrames() // Then: empty // 📦 framealso XCTAssertTrue( frames.isEmpty, "Should return empty dictionary without channels") } /** * * @section ___________________ ✅: without channels query * ──────────────────────────────────────────────────────────────────── * getBufferStatus() empty Return * Verify. * * 📦? * @endcode * each frame: * * front: * [Frame][Frame][Frame]...[Frame] 25/30 (83%) * * rear: * [Frame][Frame][Frame][Frame]... 28/30 (93%) * * getBufferStatus() Return: * [ *.front: BufferStatus(current: 25, maximum: 30, fillPercentage: 0.83), *.rear: BufferStatus(current: 28, maximum: 30, fillPercentage: 0.93) * ] * @endcode * * * @section _________ 💡 * @endcode * UI: * [████████░░] 83% - front * [█████████░] 93% - rear * *: * - → decoding * - → * @endcode * * * @section _____ 🔍 Return * @endcode * [CameraPosition: BufferStatus] * * struct BufferStatus { * let current: Int // * let maximum: Int // * let fillPercentage: Double // 0.0 ~ 1.0 * } * @endcode * * * @section ________ ⚠️ * @endcode * let status = getBufferStatus() * status.isEmpty // true * @endcode * * @test testGetBufferStatusWithNoChannels * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> SyncController * - <b>When:</b> getBufferStatus() * - <b>Then:</b> empty Return * @endcode */ func testGetBufferStatusWithNoChannels() { // When: query let status = syncController.getBufferStatus() // Then: empty // 📦 also XCTAssertTrue( status.isEmpty, "Should return empty dictionary without channels") } // ======================================================================== // MARK: - Time Formatting Tests // ======================================================================== // // 🎯 Purpose: time formatting functionality Verify. // // ✅ Verify: // - currentTimeString () // - durationString () // - remainingTimeString () // - playbackSpeedString ( also) // - value /** * * @section ______________ ✅: * ──────────────────────────────────────────────────────────────────── * currentTimeString Verify. * * 🕐: * @endcode * MM:SS (:seconds) * *: * 0seconds → "00:00" * 30seconds → "00:30" * 90seconds → "01:30" * 3665seconds → "61:05" (61 5seconds) * @endcode * * * @section __hh_mm_ss_____mm_ss____ 💡 HH:MM:SS MM:SS? * @endcode * 1~3: * - 00:00:30 ( 00:) * - 00:30 () ✅ * * 60: * - 01:30:00 () * - 90:00 (90) ✅ * @endcode * * * @section _____ 🔄 * @endcode * let totalSeconds = Int(currentTime) * let minutes = totalSeconds / 60 // 90 / 60 = 1 * let seconds = totalSeconds % 60 // 90 % 60 = 30 * return String(format: "%02d:%02d", minutes, seconds) * // → "01:30" * @endcode * * @test testCurrentTimeString * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> currentTime = 0.0 * - <b>When:</b> currentTimeString property * - <b>Then:</b> "00:00" Return * @endcode */ func testCurrentTimeString() { // Given: currentTime = 0 // (setUp() initialization) // When: query let timeString = syncController.currentTimeString // Then: "00:00" XCTAssertEqual(timeString, "00:00") } /** * * @section ________________ ✅: * ──────────────────────────────────────────────────────────────────── * durationString Verify. * * 🕐 duration: * @endcode * entire: * * [━━━━━━━━━━━━━━━━━━━━━━━] 3:00 ← durationString * ↑ ↑ * 0seconds 180seconds * @endcode * * * @section ui______ 💡 UI * @endcode * Text(": \(syncController.durationString)") * // → ": 03:00" * * //: * [▓▓▓▓▓░░░░░] 01:30 / 03:00 * ↑ ↑ * current duration * @endcode * * @test testDurationString * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> duration = 0.0 () * - <b>When:</b> durationString property * - <b>Then:</b> "00:00" Return * @endcode */ func testDurationString() { // Given: duration = 0 // ( load) // When: query let durationString = syncController.durationString // Then: "00:00" XCTAssertEqual(durationString, "00:00") } /** * * @section ______________ ✅: * ──────────────────────────────────────────────────────────────────── * remainingTimeString Verify. * * 🕐: * @endcode * remaining = duration - currentTime * *: * duration = 180seconds (3) * currentTime = 90seconds (1 30seconds) * remaining = 180 - 90 = 90seconds (1 30seconds) * → "-01:30" ( -) * @endcode * * * @section ________________ 💡 (-)? * @endcode * UI: * - " " - * * [▓▓▓▓▓░░░░░] 01:30 / 03:00 (-01:30) * ↑ ↑ ↑ * entire * @endcode * * * @section _____ 🔄 * @endcode * let remaining = duration - currentTime // 90.0 * let formatted = formatTime(remaining) // "01:30" * return "-\(formatted)" // "-01:30" * @endcode * * @test testRemainingTimeString * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> duration = 0, currentTime = 0 * (remaining = 0) * - <b>When:</b> remainingTimeString property * - <b>Then:</b> "-00:00" Return * @endcode */ func testRemainingTimeString() { // Given: remaining = 0 // (duration - currentTime = 0 - 0 = 0) // When: query let remainingString = syncController.remainingTimeString // Then: "-00:00" () XCTAssertEqual(remainingString, "-00:00") } /** * * @section ______________ ✅: also * ──────────────────────────────────────────────────────────────────── * playbackSpeedString Verify. * * * @section ________ ⚡ also * @endcode * 0.5x → () * 1.0x → also * 1.5x → 1.5 (fast) * 2.0x → 2 * @endcode * * * @section ui______ 💡 UI * @endcode * Button(syncController.playbackSpeedString) { * // also * } * // → "1.5x" * * //: * Text(" also: \(syncController.playbackSpeedString)") * // → " also: 1.5x" * @endcode * * * @section ___ 🔄 * @endcode * playbackSpeed = 1.5 * return "\(playbackSpeed)x" // "1.5x" * * playbackSpeed = 1.0 * return "\(playbackSpeed)x" // "1.0x" * @endcode * * @test testPlaybackSpeedString * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> playbackSpeed 1.5 * - <b>When:</b> playbackSpeedString property * - <b>Then:</b> "1.5x" Return * @endcode */ func testPlaybackSpeedString() { // Given: also 1.5 syncController.playbackSpeed = 1.5 // When: also query let speedString = syncController.playbackSpeedString // Then: "1.5x" XCTAssertEqual(speedString, "1.5x") } /** * * @section ________________ ✅: value * ──────────────────────────────────────────────────────────────────── * value correctly Verify. * * * @section _______ 📊 * @endcode * 0seconds → "00:00" (0 0seconds) * 30seconds → "00:30" (0 30seconds) * 60seconds → "01:00" (1 0seconds) * 90seconds → "01:30" (1 30seconds) * 3600seconds → "60:00" (60 0seconds) * 3665seconds → "61:05" (61 5seconds) * @endcode * * * @section ________ 💡 * @endcode * func formatTime(_ seconds: TimeInterval) -> String { * let total = Int(seconds) * let min = total / 60 // * let sec = total % 60 // * return String(format: "%02d:%02d", min, sec) * } * * //: 3665seconds * // min = 3665 / 60 = 61 * // sec = 3665 % 60 = 5 * // → "61:05" * @endcode * * * @section _02d_______ 🔍 %02d * @endcode * %02d = 2, empty 0 * * 5 → "%02d" → "05" * 30 → "%02d" → "30" * 100 → "%02d" → "100" (2) * @endcode * * @test testTimeFormatting * @brief 📝 Note: * * @details * * @section note 📝 Note * private method, * Swift private method. * Integration Tests public API Verify. */ func testTimeFormatting() { // Test various time values let testCases: [(TimeInterval, String)] = [ (0, "00:00"), // 0seconds (30, "00:30"), // 30seconds (60, "01:00"), // 1 (90, "01:30"), // 1 30seconds (3600, "60:00"), // 60 (3665, "61:05") // 61 5seconds ] // 💡 each Expected Result for (time, expected) in testCases { // Use private method through reflection or test computed property // For now, test through public API // // 📝 Swift private method // → Integration Tests actual Verify // // internal: // @testable import internal can access } } // ======================================================================== // MARK: - Playback Speed Tests // ======================================================================== // // 🎯 Purpose: also functionality Verify. // // ✅ Verify: // - also Combine // - Drift threshold () /** * * @section _____________ ✅: also * ──────────────────────────────────────────────────────────────────── * playbackSpeed property Combine * value normally Verify. * * * @section ____________ ⚡ also and * @endcode * 1.0x (): * - 1seconds actual 1seconds * - 30fps → seconds 30frame * * 0.5x (): * - 1seconds actual 2seconds * - 30fps → seconds 15frame * * 2.0x (): * - 1seconds actual 0.5seconds * - 30fps → seconds 60frame * @endcode * * * @section ________ 🔄 also * @endcode * UI also: * syncController.playbackSpeed = 2.0 * ↓ * @Published value * ↓ *.sink { speed in } // subscribe * ↓ * each VideoChannel decoding Speed Control * ↓ * also * @endcode * * * @section _________ 💡 also * @endcode * // also also * syncController.play() * syncController.playbackSpeed = 1.5 // * // → 1.5 * @endcode * * @test testPlaybackSpeedChange * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> playbackSpeed subscribe * - <b>When:</b> playbackSpeed 2.0 * - <b>Then:</b> secondsvalue(1.0)and value(2.0) * @endcode */ func testPlaybackSpeedChange() { // Given: also subscribe // 🎯 Tasks complete Expectation let expectation = expectation(description: "Playback speed changed") // ⚡ also value array var receivedSpeeds: [Double] = [] // 🔄 @Published playbackSpeed subscribe syncController.$playbackSpeed.sink { speed in // 💡 value: // 1. secondsvalue 1.0 (subscribe) // 2. value 2.0 () // also receivedSpeeds.append(speed) // 2 expectation complete if receivedSpeeds.count >= 2 { expectation.fulfill() } }.store(in: &cancellables) // When: also 2 syncController.playbackSpeed = 2.0 // Then: value Verify // ⏱️ 1seconds wait(for: [expectation], timeout: 1.0) // ⚡ value 2.0 XCTAssertEqual(receivedSpeeds.last, 2.0) // 💡 entire value: [1.0, 2.0] // -: secondsvalue (setUp) // -: value () } /** * * @section _____drift_threshold____________ ✅: Drift Threshold () * ──────────────────────────────────────────────────────────────────── * Drift threshold 50ms Confirm. * * * @section drift__ 🔄 Drift? * @endcode * channel synchronization: * *: 3.500seconds * * front: frame @ 3.498seconds (drift: -2ms) ✅ * rear: frame @ 3.530seconds (drift: +30ms) ✅ * side: frame @ 3.555seconds (drift: +55ms) ❌ secondsand * * Drift Threshold = 50ms * → ±50ms within frame "" * @endcode * * * @section __drift________ 💡 Drift? * @endcode *: * 1. * 2. and * 3. I-Frameand P-Frame * 4. (IP) * @endcode * * * @section 50ms________ 🎯 50ms * @endcode * each: * - 20ms: * - 20~50ms: () * - 50ms: * * 30fps: * - frame: 33ms * - 50ms = 1.5frame * - 2frame * @endcode * * 🔧 Drift: * @endcode * func getSynchronizedFrames() -> [CameraPosition: VideoFrame] { * let targetTime = currentTime * * for channel in channels { * let frame = channel.getFrame(at: targetTime) * * // Drift Confirm * let drift = abs(frame.timestamp - targetTime) * if drift > driftThreshold { // 50ms * // frame * continue * } * * frames[channel.position] = frame * } * } * @endcode * * @test testDriftThreshold * @brief 📝 Note: * * @details * * @section note 📝 Note * driftThreshold internal property, * Integration Tests actual Verify. */ func testDriftThreshold() { // Drift threshold should be 50ms // This is an internal property, tested through integration // // 📝 Drift threshold 50ms (0.05seconds). // // 💡 value SyncController internal property: // ```swift // private let driftThreshold: TimeInterval = 0.05 // 50ms // ``` // // 🔍 actual Integration Tests Verify: // - actual file load // - channel synchronization // - each drift // - 50ms within Confirm } // ======================================================================== // MARK: - Thread Safety Tests // ======================================================================== // // 🎯 Purpose: Verify. // // ✅ Verify: // - (channelCount, allChannelsReady) // - frame (getSynchronizedFrames, getBufferStatus) // - complete /** * * @section ________________ ✅: information * ──────────────────────────────────────────────────────────────────── * information also * Verify. * * 🔒 Thread safety? * @endcode * data also * data * *: * Thread 1: channelCount read → 3 * Thread 2: channels array → [ch1, ch2] * Thread 1: channels[2] → ❌ Index out of range! * @endcode * * 🔧 Thread safety: * @endcode * 1. NSLock use: * let lock = NSLock() * lock.lock() * defer { lock.unlock() } * // * * 2. DispatchQueue use: * let queue = DispatchQueue(label: "sync") * queue.sync { * // * } * * 3. Actor (Swift 5.5+): * actor SyncController { * // Thread safety * } * @endcode * * 🧪 DispatchQueue.concurrentPerform? * @endcode * DispatchQueue.concurrentPerform(iterations: 100) { i in * // 100 * } * *: * - GCD * - * - * @endcode * * * @section __________ 💡 actual use Scenario * @endcode *: * * UI Thread: syncController.channelCount * Decoding Thread: videoChannel.decode() * Network Thread: gpsService.update() * ↓ * SyncController data * ↓ * Thread safety! * @endcode * * @test testConcurrentChannelAccess * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> SyncController instance * - <b>When:</b> 100 information * - <b>Then:</b> complete * @endcode */ func testConcurrentChannelAccess() { // When: Access channel count from multiple threads // 🔄 100 DispatchQueue.concurrentPerform(iterations: 100) { _ in // 📺 read (read) _ = syncController.channelCount // ✅ Confirm (read) _ = syncController.allChannelsReady // 💡 property 100 // → complete } // Then: Should not crash // 💡 syncController nil complete XCTAssertNotNil(syncController) // 📝 Note: actual also //. // Thread Sanitizer use } /** * * @section ______________ ✅: frame * ──────────────────────────────────────────────────────────────────── * frame data also * Verify. * * 📦 method: * @endcode * getSynchronizedFrames(): * - all channels frame query * - Dictionary Return (read) * * getBufferStatus(): * - all channels query * - Dictionary Return (read) * @endcode * * * @section ________________ 💡 frame? * @endcode * actual: * * Render Thread: getSynchronizedFrames() // 60fps * UI Thread: getBufferStatus() // seconds * Export Thread: getSynchronizedFrames() // 30fps * * → seconds! * → Thread safety * @endcode * * 🔒 data: * @endcode * // SyncController * private var channels: [VideoChannel] = [] // ← * private var currentFrames: [CameraPosition: VideoFrame] = [:] * * //: * func getSynchronizedFrames() -> [CameraPosition: VideoFrame] { * lock.lock() * defer { lock.unlock() } * return currentFrames * } * @endcode * * * @section race_condition___ ⚠️ Race Condition * @endcode *: * * Thread A: Thread B: * frames = getSynced() frames = getSynced() * ↓ ↓ * for (pos, frame) in frames * ↓ channels.removeAll() * frame.render() ↓ * ↓ 💥 frames! * ❌! * @endcode * * @test testConcurrentFrameAccess * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> SyncController instance * - <b>When:</b> 100 frame/ query * - <b>Then:</b> query complete * @endcode */ func testConcurrentFrameAccess() { // When: Get synchronized frames from multiple threads // 🔄 100 DispatchQueue.concurrentPerform(iterations: 100) { _ in // 🎬 frame query _ = syncController.getSynchronizedFrames() // 📊 query _ = syncController.getBufferStatus() // 💡 method 100 // → channels array // → complete } // Then: Should not crash // 💡 complete Confirm XCTAssertNotNil(syncController) // 📝 Verify: // - Thread Sanitizer data // - Instruments Confirm // - Stress Test } // ======================================================================== // MARK: - Memory Management Tests // ======================================================================== // // 🎯 Purpose: Memory management correctly Verify. // // ✅ Verify: // - deinit () // - stop() method cleanup // - /** * * @section _____deinit______ ✅: deinit Confirm * ──────────────────────────────────────────────────────────────────── * SyncController nil normally * Verify. * * 🧠 ARC (Automatic Reference Counting)? * @endcode * Swift Memory management: * * 1. object create: * let controller = SyncController() * → Reference Count: 1 * * 2.: * let another = controller * → Reference Count: 2 * * 3.: * controller = nil * → Reference Count: 1 * * 4.: * another = nil * → Reference Count: 0 * → deinit * → * @endcode * * * @section deinit____ 💡 deinit * @endcode * class SyncController { * deinit { * // * // 1. * // 2. file * // 3. * // 4. * } * } * @endcode * * * @section _________ ⚠️ * @endcode * // (Retain Cycle): * class A { * var b: B? * } * class B { * var a: A? // * } * let a = A() * let b = B() * a.b = b * b.a = a //! * a = nil * b = nil * // → deinit! 💥 * * //: weak unowned use * class B { * weak var a: A? // ✅ * } * @endcode * * * @section _____________ 🔍 Confirm * @endcode * 1. controller = nil * 2. 0 * 3. deinit * 4. actual * @endcode * * @test testDeinit * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> SyncController instance create ( 1) * - <b>When:</b> nil ( 0) * - <b>Then:</b> (controller nil) * @endcode */ func testDeinit() { // Given: SyncController instance create // 💡 nil can var controller: SyncController? = SyncController() //: 1 // When: nil controller = nil //: 0 → deinit → // Then: nil // 💡 controller nil XCTAssertNil(controller) // 📝 Confirm available: // - Instruments Leaks also Confirm // - deinit print Confirm // - } /** * * @section _____stop__________ ✅: stop() cleanup * ──────────────────────────────────────────────────────────────────── * stop() method cleanup Verify. * * 🧹 stop() method cleanup Tasks: * @endcode * 1.: * - playbackState =.stopped * - * * 2. cleanup: * - VideoChannel * - channels array * - channelCount = 0 * * 3. initialization: * - currentTime = 0.0 * - duration = 0.0 * - playbackPosition = 0.0 * * 4. Sensor Services cleanup: * - GPS data cleanup * - G-Sensor data cleanup * @endcode * * * @section stop___vs_deinit___ 💡 stop() vs deinit * @endcode * stop(): * - * - cleanup + initialization * - object * - loadVideoFile() * * deinit: * - (ARC) * - * - object * - use * @endcode * * * @section __________ 🔄 use * @endcode * // 1 * syncController.loadVideoFile(video1) * syncController.play() * * // * syncController.stop() // cleanup * syncController.loadVideoFile(video2) // load * syncController.play() * * // * syncController = nil // deinit * @endcode * * * @section stop____________ ⚠️ stop() * @endcode * loadVideoFile(video2) // stop() load * → VideoChannel * →! * → decoding * @endcode * * @test testStopClearsResources * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> SyncController instance * - <b>When:</b> stop() method * - <b>Then:</b> secondsvalue * @endcode */ func testStopClearsResources() { // When: stop() method syncController.stop() // Then: cleanup // 📺 0 initialization XCTAssertEqual(syncController.channelCount, 0) // ⏱️ 0.0 initialization XCTAssertEqual(syncController.currentTime, 0.0) // ⏲️ 0.0 initialization XCTAssertEqual(syncController.duration, 0.0) // 💡 Confirm: // - playbackState ==.stopped // - playbackPosition == 0.0 // - allChannelsReady == false // - getSynchronizedFrames().isEmpty == true // - getBufferStatus().isEmpty == true } // ======================================================================== // MARK: - Performance Tests // ======================================================================== // // 🎯 Purpose: Confirm. // // ✅ Verify: // - getSynchronizedFrames() // - getBufferStatus() // - 1000 /** * * @section _____getsynchronizedframes_____ ✅: getSynchronizedFrames() * ──────────────────────────────────────────────────────────────────── * getSynchronizedFrames() method 1000 *. * * ⏱️ measure {}? * @endcode * measure { * // 10 * // each * //, * } * * and: * 1: 0.015seconds * 2: 0.014seconds * 3: 0.016seconds *... * 10: 0.015seconds * ↓ *: 0.015seconds ± 0.001seconds * ↓ * Xcode Baseline * @endcode * * * @section _____ 📊 * @endcode *: 1000 < 10ms * *: * - 60fps = 16.67ms per frame * - getSynchronizedFrames() frame * - 1 < 0.01ms * - 1000 < 10ms * * result: * * @section 5ms___________________ ✅ 5ms → () * * @section 15ms______________ ⚠️ 15ms → () * ❌ 50ms → () * @endcode * * * @section __________ 💡 * @endcode * //: * func getSynchronizedFrames() -> [CameraPosition: VideoFrame] { * var result: [CameraPosition: VideoFrame] = [:] * for channel in channels { * let frame = channel.decode() // ❌ decoding * result[channel.position] = frame * } * return result * } * * // fast: * func getSynchronizedFrames() -> [CameraPosition: VideoFrame] { * return currentFrames // ✅ frame Return * } * @endcode * * * @section xcode_baseline___ 🔍 Xcode Baseline functionality * @endcode * 1. * 2. "Set Baseline" * 3. Baselineand * 4. 10% * @endcode * * @test testGetSynchronizedFramesPerformance * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> SyncController instance () * - <b>When:</b> getSynchronizedFrames() 1000 * - <b>Then:</b> within * @endcode */ func testGetSynchronizedFramesPerformance() { // ⏱️ measure Performance measurement measure { // 💡 1000 for _ in 0..<1000 { // 🎬 frame query _ = syncController.getSynchronizedFrames() // 📝 Note: empty Return // → // → Integration Tests actual } } // 💡 measure: // - Xcode Test Navigator // - Baselineand () // - } /** * * @section _____getbufferstatus_____ ✅: getBufferStatus() * ──────────────────────────────────────────────────────────────────── * getBufferStatus() method 1000 *. * * * @section _____ 📊 * @endcode *: 1000 < 10ms * *: * - UI use (seconds 1~10) * - (,) * - UI fast * @endcode * * * @section ___________ 💡 * @endcode * func getBufferStatus() -> [CameraPosition: BufferStatus] { * var result: [CameraPosition: BufferStatus] = [:] * for channel in channels { * let status = BufferStatus( * current: channel.buffer.count, // O(1) * maximum: channel.buffer.capacity, // O(1) * fillPercentage: Double(channel.buffer.count) / * Double(channel.buffer.capacity) // O(1) *) * result[channel.position] = status * } * return result // O(n), n = * } * @endcode * * * @section ______ 🎯 * @endcode * 1.: * - * - value Return * * 2. Lazy: * - * - use * * 3.: * - * - DispatchQueue.concurrentPerform use * @endcode * * @test testGetBufferStatusPerformance * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> SyncController instance () * - <b>When:</b> getBufferStatus() 1000 * - <b>Then:</b> within * @endcode */ func testGetBufferStatusPerformance() { // ⏱️ measure Performance measurement measure { // 💡 1000 for _ in 0..<1000 { // 📊 query _ = syncController.getBufferStatus() // 📝 Note: empty Return // → method // → actual Integration Tests Confirm } } // 💡: // - getSynchronizedFrames() () // - lock // - Thread Sanitizer Confirm } } // ============================================================================ // MARK: - Integration Tests // ============================================================================ /// 🔗 SyncControllerIntegrationTests /// ──────────────────────────────────────────────────────────────────────── /// actual fileand use SyncController entire /// Verify Integration Test. /// /// 📝 Unit Tests vs Integration Tests: /// ``` /// Unit Tests (SyncControllerTests): /// ├─ without channels independently /// ├─ fast (< 1seconds) /// ├─ method Verify /// └─ Mock data use /// /// Integration Tests (this class): /// ├─ actual file load /// ├─ ( seconds) /// ├─ entire Verify /// └─ actual data use /// ``` /// /// 🎯 Test Scope: /// ``` /// 1. file load /// 2. (.paused →.playing →.paused) /// 3. Seeking /// 4. channel synchronization /// 5. playback speed control /// 6. Confirm /// 7. (.playing →.stopped) /// ``` /// /// ⚠️ XCTSkip? /// ```swift /// guard let videoPath =... else { /// throw XCTSkip("Test video file not found") /// } /// ///: /// - (failure) /// - CI/CD /// - result "Skipped" /// ``` final class SyncControllerIntegrationTests: XCTestCase { // ======================================================================== // MARK: - Properties // ======================================================================== /** * 📦 Test target SyncController instance */ var syncController: SyncController! /** * * @section ______________ 🎬 file information * @endcode * VideoFile: * - actual file path * - information (front) * - data (duration, size) * @endcode */ var testVideoFile: VideoFile! // ======================================================================== // MARK: - Setup & Teardown // ======================================================================== /** * 🔧 setUp method * ──────────────────────────────────────────────────────────────────── * each fileand SyncController. * * 📦 Bundle? * @endcode * let bundle = Bundle(for: type(of: self)) * *: * - * - test_video.mp4 file * - path * @endcode * * * @section _____________ 🎬 file * @endcode * test_video.mp4 * ├─ front (Front Camera) * ├─: 10seconds * ├─ also: 1920x1080 * └─ frame: 30fps * @endcode * * * @section xctskip___ ⚠️ XCTSkip use * @endcode * file: * - failure ❌ ( also) * - Skip ✅ () * @endcode */ override func setUpWithError() throws { super.setUp() // Create test video file // 📦 let bundle = Bundle(for: type(of: self)) // 🎬 file path guard let videoPath = bundle.path(forResource: "test_video", ofType: "mp4") else { // ⚠️ file throw XCTSkip("Test video file not found") // 💡 XCTSkip throw: // - "Skipped" // - // - CI/CD and } // Create test video file with channels // 🎬 VideoFile instance create testVideoFile = VideoFile( id: UUID(), // ID timestamp: Date(), // create eventType:.normal, // duration: 10.0, // 10seconds channels: [ // front 1 ChannelInfo( position:.front, // front filePath: videoPath, // actual file path width: 1920, // Full HD height: 1080, // Full HD frameRate: 30.0 // 30 fps) ], metadata: VideoMetadata.empty, // empty data basePath: videoPath // path) // 🔧 SyncController create syncController = SyncController() } /** * 🧹 tearDown method * ──────────────────────────────────────────────────────────────────── * each cleanup. * * 🧹 cleanup: * @endcode * 1. syncController.stop() →, * 2. syncController = nil → * 3. testVideoFile = nil → file information * 4. super.tearDown() → cleanup * @endcode */ override func tearDownWithError() throws { // 🎮 cleanup syncController.stop() // 🗑️ syncController = nil testVideoFile = nil // 🧹 cleanup super.tearDown() } // ======================================================================== // MARK: - Integration Test Cases // ======================================================================== /** * * @section ______________ ✅: file load * ──────────────────────────────────────────────────────────────────── * actual file load normally initialization * Verify. * * * @section loadvideofile_____ 🔄 loadVideoFile() * @endcode * 1. VideoFile information read * 2. each VideoChannel create * - FFmpeg decoder initialization * - file * - data read * 3. duration () * 4. playbackState =.paused * 5. allChannelsReady = true * @endcode * * @test testLoadVideoFile * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> file * - <b>When:</b> loadVideoFile() * - <b>Then:</b>.paused, /duration * @endcode */ func testLoadVideoFile() throws { // When: file load try syncController.loadVideoFile(testVideoFile) // Then: load Verify // 🎮.paused ( complete) XCTAssertEqual(syncController.playbackState,.paused) // 📺 1 load XCTAssertGreaterThan(syncController.channelCount, 0) // ⏲️ (> 0seconds) XCTAssertGreaterThan(syncController.duration, 0) // ✅ complete XCTAssertTrue(syncController.allChannelsReady) } /** * * @section _____________ ✅: entire * ──────────────────────────────────────────────────────────────────── * → entire Verify. * * * @section _____ 🔄 * @endcode *.stopped * ↓ loadVideoFile() *.paused ( complete) * ↓ play() *.playing (, currentTime) * ↓ pause() *.paused (, currentTime) * @endcode * * @test testPlaybackFlow * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> load * - <b>When:</b> play() → 0.5seconds → pause() * - <b>Then:</b>, Confirm * @endcode */ func testPlaybackFlow() throws { // Given: load try syncController.loadVideoFile(testVideoFile) // When: Play // 🎮 syncController.play() // Then: Confirm // 🎮.playing XCTAssertEqual(syncController.playbackState,.playing) // Wait for some playback // ⏱️ 0.5seconds ( also) Thread.sleep(forTimeInterval: 0.5) // Then: Time should advance // ⏱️ 0 () XCTAssertGreaterThan(syncController.currentTime, 0.0) // When: Pause // ⏸️ syncController.pause() // Then: Confirm // 🎮.paused XCTAssertEqual(syncController.playbackState,.paused) } /** * * @section __________seeking ✅: Seeking * ──────────────────────────────────────────────────────────────────── * functionality Verify. * * * @section seeking___ 🎬 Seeking * @endcode * (3.0seconds): * [====●===============] 10seconds * * seekToTime(5.0): * [=========●==========] 10seconds * 5.0seconds * *: * - currentTime = 5.0 * - playbackPosition = 0.5 * - 5seconds * - * @endcode * * @test testSeekDuringPlayback * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> * - <b>When:</b> seekToTime(5.0) * - <b>Then:</b> currentTime 5.0 * @endcode */ func testSeekDuringPlayback() throws { // Given: load try syncController.loadVideoFile(testVideoFile) syncController.play() // ⏱️ 0.3seconds (seek seconds) Thread.sleep(forTimeInterval: 0.3) // When: 5seconds syncController.seekToTime(5.0) // Then: Seeking result Verify // ⏱️ 5.0seconds XCTAssertEqual(syncController.currentTime, 5.0) // 📍 0 (5.0 / 10.0 = 0.5) XCTAssertGreaterThan(syncController.playbackPosition, 0.0) } /** * * @section ________________ ✅: frame query * ──────────────────────────────────────────────────────────────────── * channel synchronization Verify. * * * @section _______ 🔄 frame * @endcode *: 3.5seconds * * front: * [...frame @ 3.498seconds...] ← drift: -2ms ✅ * * getSynchronizedFrames() Return: * [ *.front: VideoFrame(timestamp: 3.498) * ] * @endcode * * @test testSynchronizedFrames * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> * - <b>When:</b> getSynchronizedFrames() * - <b>Then:</b> each frame Return * @endcode */ func testSynchronizedFrames() throws { // Given: load try syncController.loadVideoFile(testVideoFile) syncController.play() // ⏱️ 0.5seconds (frame) Thread.sleep(forTimeInterval: 0.5) // When: frame query let frames = syncController.getSynchronizedFrames() // Then: frame Verify // 📦 frame XCTAssertFalse(frames.isEmpty, "Should have synchronized frames") // 🎬 each frame Verify for (position, frame) in frames { // ⏱️ 0 XCTAssertGreaterThanOrEqual(frame.timestamp, 0.0) // 📝 ( Confirm) print("Channel \(position.displayName): frame at \(frame.timestamp)s") } } /** * * @section _____________ ✅: playback speed control * ──────────────────────────────────────────────────────────────────── * 2 actual Verify. * * * @section ________ ⚡ also * @endcode * playbackSpeed = 2.0 (2) * actual: 0.5seconds *: 0.5seconds × 2.0 = 1.0seconds * *: * startTime = 0.0 * (0.5seconds) * endTime ≈ 1.0seconds * elapsed = 1.0 - 0.0 = 1.0seconds * * Verify: elapsed > 0.8 () * @endcode * * @test testPlaybackSpeedControl * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> load, 2 * - <b>When:</b> 0.5seconds * - <b>Then:</b> 1seconds (2 and) * @endcode */ func testPlaybackSpeedControl() throws { // Given: load try syncController.loadVideoFile(testVideoFile) // When: Set speed to 2x // ⚡ 2 syncController.playbackSpeed = 2.0 // 🎮 syncController.play() // 📊 let startTime = syncController.currentTime // ⏱️ 0.5seconds (actual) Thread.sleep(forTimeInterval: 0.5) // 📊 let endTime = syncController.currentTime // Then: Should advance approximately 1 second (0.5s * 2x speed) // 📊 and let elapsed = endTime - startTime // ⚡ 0.8seconds (2 1seconds) // 💡 0.8 ( 1seconds) XCTAssertGreaterThan(elapsed, 0.8, "Should advance faster at 2x speed") } /** * * @section _____________ ✅: query * ──────────────────────────────────────────────────────────────────── * each normally Verify. * * * @section ________ 📊 * @endcode * front: * [Frame][Frame][Frame]...[ ] 25/30 (83%) * * getBufferStatus() Return: * [ *.front: BufferStatus( * current: 25, * maximum: 30, * fillPercentage: 0.83 *) * ] * @endcode * * @test testBufferStatus * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> * - <b>When:</b> getBufferStatus() * - <b>Then:</b> each Return * @endcode */ func testBufferStatus() throws { // Given: load try syncController.loadVideoFile(testVideoFile) syncController.play() // ⏱️ 0.5seconds () Thread.sleep(forTimeInterval: 0.5) // When: query let status = syncController.getBufferStatus() // Then: Verify // 📦 XCTAssertFalse(status.isEmpty) // 📊 each Verify for (position, bufferStatus) in status { // 📦 1 frame XCTAssertGreaterThan( bufferStatus.current, 0, "Channel \(position.displayName) should have buffered frames") // 📊 0.0 ~ 1.0 XCTAssertLessThanOrEqual(bufferStatus.fillPercentage, 1.0) } } /** * * @section ___________ ✅: * ──────────────────────────────────────────────────────────────────── * Verify. * * * @section _________ 🔄 * @endcode *: * [●═══════════════════] 0.0seconds / 10.0seconds * ↓ play() * [════════════════●═══] 8.5seconds / 10.0seconds * ↓ () * [═══════════════════●] 10.0seconds / 10.0seconds * ↓ () *.stopped (currentTime = 10.0, position = 1.0) * @endcode * * ⏱️ Polling: * @endcode * while playbackState ==.playing { * Thread.sleep(0.1seconds) * elapsed += 0.1seconds * if elapsed > timeout { break } * } * @endcode * * @test testPlayToEnd * @brief 📝 Given-When-Then: * * @details * * @section given_when_then___ 📝 Given-When-Then * @endcode * - <b>Given:</b> 10seconds load * - <b>When:</b>, * - <b>Then:</b>, currentTime = duration * @endcode */ func testPlayToEnd() throws { // Given: Short video // 🎬 10seconds load try syncController.loadVideoFile(testVideoFile) // When: Play to end // 🎮 syncController.play() // Wait for playback to complete // ⏱️ (duration + 2seconds) let timeout = syncController.duration + 2.0 // ⏱️ and var elapsed: TimeInterval = 0.0 // ⏱️ Confirm (0.1seconds Confirm) let checkInterval: TimeInterval = 0.1 // 🔄 (Polling) while syncController.playbackState ==.playing && elapsed < timeout { // 0.1seconds Thread.sleep(forTimeInterval: checkInterval) // and elapsed += checkInterval } // Then: Should stop at end // 🎮.stopped () XCTAssertEqual(syncController.playbackState,.stopped) // ⏱️ = duration () XCTAssertEqual(syncController.currentTime, syncController.duration) // 📍 = 1.0 (100%) XCTAssertEqual(syncController.playbackPosition, 1.0) } } 