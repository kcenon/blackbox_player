/** * @file SyncControllerTests.swift * @brief Unit Tests and Integration Tests for SyncController class * @author BlackboxPlayer Team * * @details * * @section sync_overview SyncController Overview * * A central control component that synchronizes and plays multiple VideoChannels. * * @subsection sync_structure Multi-Channel Synchronization Structure * * @endcode * SyncController (central controller) * â”œâ”€â”€ VideoChannel (front) â”€â”€â†’ frame @ 3.500seconds * â”œâ”€â”€ VideoChannel (rear) â”€â”€â†’ frame @ 3.502seconds * â”œâ”€â”€ VideoChannel (side) â”€â”€â†’ frame @ 3.498seconds * â”œâ”€â”€ GPSService â”€â”€â†’ GPS data * â””â”€â”€ GSensorService â”€â”€â†’ G-Sensor data * â†“ * Time Synchronization (Â± 50ms within) * â†“ * Display on screen: all channels 3.5seconds frame * @endcode * * @subsection sync_features Key Features * * -# <b>Channel Management</b>: Load and manage multiple video channels * -# <b>Playback Control</b>: play, pause, stop, seek * -# <b>Time Synchronization</b>: Align all channels to the same timestamp * -# <b>Speed Control</b>: 0.5x ~ 2.0x playback speed control * -# <b>Sensor Services</b>: Manage GPS and G-sensor data * * @subsection test_scope Test Scope * * - Initialization and state management * - Playback Control (play, pause, stop, seek) * - channel synchronization * - time formatting * - Thread safety * - Memory management * - Performance measurement */ // ============================================================================ // MARK: - Imports // ============================================================================ /** * @brief Apple frame * * @details * XCTestCase inherit create a class, * XCTAssert with functions Verify perform. */ import XCTest /** * @brief Apple Reactive Programming frame * * @details * used in this test Combine functionality: * * @endcode * // 1. @Published property subscribe: * syncController.$playbackState *.sink { state in... } * * // 2. value: * syncController.$currentTime *.sink { time in... } * * // 3. AnyCancellable subscribe: *.store(in: &cancellables) * @endcode */ import Combine /** * @brief Test target module import * * @details * @testable when attached internal access modifiers can be used. * * @note access control levels: * @endcode * open > public > internal > fileprivate > private * â†‘ â†‘ * can subclass @testable can access * @endcode */ @testable import BlackboxPlayer // ============================================================================ // MARK: - SyncControllerTests (Unit Tests) // ============================================================================ /** * @class SyncControllerTests * @brief SyncController basic behavior Verify Unit Test * * @details * SyncController each methodand property independently. * * @section unit_vs_integration Unit Tests vs Integration Tests * * <b>Unit Tests (this class):</b> * - without channels standalone * - fast * - method Verify * - Mock data use * * <b>Integration Tests (SyncControllerIntegrationTests):</b> * - actual file load * - entire * - * - actual data use * * @section test_targets Test target * * - initial state Verify * - * - Playback Control method * - Seeking * - time formatting * - Thread safety * - Memory management * * @note final * inherit final. * @endcode * final class SyncControllerTests // âœ… * class SyncControllerTests // âŒ can subclass * @endcode */ final class SyncControllerTests: XCTestCase { // ======================================================================== // MARK: - Properties // ======================================================================== /** * @var syncController * @brief Test target SyncController instance * * @details * each method setUp() create. * * @note Implicitly Unwrapped Optional (!) use * * <b>:</b> * - setUp() initialization * - * - * * @endcode * // and: * setUp() â†’ syncController = SyncController() * â†’ syncController.play() // * tearDown() â†’ syncController = nil * @endcode */ var syncController: SyncController! /** * @var cancellables * @brief Combine subscribe(subscription) * * @details * @Published property subscribe create AnyCancellable object * Set. * * @note Combine subscribe lifecycle * @endcode * // 1. subscribe create * syncController.$playbackState *.sink { state in * print("State: \(state)") * } *.store(in: &cancellables) // 2. Set * * // 3. tearDown() cancellables = nil * // â†’ Set subscribealso * @endcode * * @par Set use? * - AnyCancellable Hashable * - Set subscribe * - subscribe cleanup */ var cancellables: Set<AnyCancellable>! // ======================================================================== // MARK: - Setup & Teardown // ======================================================================== /** * @brief each method setUp method * * @details * each method ****. * * @par: * @endcode * 1. setUp() * â”œâ”€ super.setUp() * â”œâ”€ continueAfterFailure = false * â”œâ”€ syncController create * â””â”€ cancellables initialization * 2. testInitialState() * 3. tearDown() * â†“ * 4. setUp() ( instance) * 5. testPlaybackStatePublishing() * 6. tearDown() *... (each) * @endcode * * @warning continueAfterFailure = false * @endcode * // false (value): * XCTAssertEqual(a, 1) // âŒ failure * XCTAssertEqual(b, 2) // â¹ï¸ () * * // true: * XCTAssertEqual(a, 1) // âŒ failure * XCTAssertEqual(b, 2) // âœ… * @endcode * * @throws XCTest error */ override func setUpWithError() throws { // setUp super.setUp() // failure ( fast) continueAfterFailure = false // Test target SyncController create syncController = SyncController() // Combine subscribe initialization cancellables = [] } /** * @brief each method tearDown method * * @details * each method ****. * * @par cleanup(cleanup) Tasks: * @endcode * A: * setUp() â†’ syncController create * â†’ syncController load * tearDown() â†’ syncController.stop() + nil * * B: * setUp() â†’ syncController create * â†’ âœ… * @endcode * * @warning * @endcode * syncController.stop() // 1. * syncController = nil // 2. (ARC) * cancellables = nil // 3. subscribe * @endcode * * @par: * @endcode * 1. method complete * 2. tearDown() * â”œâ”€ syncController.stop() // * â”œâ”€ syncController = nil // instance * â”œâ”€ cancellables = nil // subscribe * â””â”€ super.tearDown() // cleanup * @endcode * * @throws XCTest error */ override func tearDownWithError() throws { // SyncController cleanup syncController.stop() // (ARC) syncController = nil // Combine subscribe cancellables = nil // tearDown super.tearDown() } // ======================================================================== // MARK: - Initialization Tests // ======================================================================== /** * @name Initialization Tests * @{ * * @test testInitialState * @brief SyncController initial state Verify * * @details * SyncController create property value * initialization Verify. * * @par Verify: * <b>:</b> * - playbackState:.stopped () * - channelCount: 0 (load) * - allChannelsReady: false () * * <b>:</b> * - currentTime: 0.0 () * - playbackPosition: 0.0 ( 0~1) * - duration: 0.0 () * * <b>:</b> * - playbackSpeed: 1.0 ( also) * * @note initial state? * @endcode * // initialization: * playbackState =.playing // âŒ? * currentTime = 100.0 // âŒ 100seconds? * * // initialization: * playbackState =.stopped // âœ… * currentTime = 0.0 // âœ… * @endcode * * @par Given-When-Then: * - <b>Given:</b> setUp() SyncController create * - <b>When:</b> () - also * - <b>Then:</b> secondsvalue */ func testInitialState() { // Then: initial state Verify // ğŸ®.stopped XCTAssertEqual( syncController.playbackState,.stopped, "Initial state should be stopped") // â±ï¸ 0seconds XCTAssertEqual( syncController.currentTime, 0.0, "Initial time should be 0") // ğŸ“ 0.0 (0%) XCTAssertEqual( syncController.playbackPosition, 0.0, "Initial position should be 0") // âš¡ also 1.0x ( also) XCTAssertEqual( syncController.playbackSpeed, 1.0, "Initial speed should be 1.0") // â²ï¸ 0seconds () XCTAssertEqual( syncController.duration, 0.0, "Initial duration should be 0") // ğŸ“º load 0 XCTAssertEqual( syncController.channelCount, 0, "Initial channel count should be 0") // âŒ () XCTAssertFalse( syncController.allChannelsReady, "Channels should not be ready initially") } /** * @test testServicesInitialization * @brief Sensor Services initialization Verify * * @details * âœ…: Sensor Services initialization * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * SyncController GPSand G-Sensor normally initialization * Verify. * * @section sensor_service ğŸŒ Sensor Services? * @endcode * SyncController * â”œâ”€â”€ GPSService * â”‚ â”œâ”€ also/also data * â”‚ â”œâ”€ also information * â”‚ â””â”€ also data * â”‚ * â””â”€â”€ GSensorService * â”œâ”€ X also * â”œâ”€ Y also * â””â”€ Z also () * @endcode * * @note ğŸ’¡: * @endcode * GPS data:, path * G-Sensor:, / * @endcode * * @par Given-When-Then: * - <b>Given:</b> setUp() SyncController create * - <b>When:</b> () - also * - <b>Then:</b> gpsServiceand gsensorService nil * * @warning âš ï¸ XCTAssertNotNil vs XCTAssertEqual: * @endcode * XCTAssertNotNil(service) // âœ… Confirm * XCTAssertEqual(service, expectedService) // value * @endcode */ func testServicesInitialization() { // Then: initialization Verify // ğŸŒ GPS initialization XCTAssertNotNil( syncController.gpsService, "GPS service should be initialized") // ğŸ“¡ G-Sensor initialization XCTAssertNotNil( syncController.gsensorService, "G-Sensor service should be initialized") } // ======================================================================== // MARK: - State Management Tests // ======================================================================== // // ğŸ¯ Purpose: and Combine Verify. // // âœ… Verify: // - // - @Published property value // - Combine subscribe /** * @test testPlaybackStateTransitions * @brief Verify * * @details * âœ…: * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * SyncController seconds.stopped Confirm. * * @section playback_flow ğŸ”„ PlaybackState: * @endcode *.stopped â”€â”€loadVideoâ”€â”€â†’.paused â”€â”€play()â”€â”€â†’.playing * â†‘ â†‘ â†“ * â””â”€â”€â”€â”€â”€â”€ stop() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€ pause() â”€â”€â”€â”€â”˜ * @endcode * * @note ğŸ’¡ Unit Test: * @endcode * Unit Test (): * - without channels initial state Confirm * - fast * * Integration Test (): * - actual load entire * -.stopped â†’.paused â†’.playing Verify * @endcode * * @par Given-When-Then: * - <b>Given:</b> setUp() SyncController create * - <b>When:</b> () - also * - <b>Then:</b> playbackState.stopped */ func testPlaybackStateTransitions() { // Given: Controller starts in.stopped state // ğŸ® initial state.stopped XCTAssertEqual(syncController.playbackState,.stopped) // ğŸ“ Note: Actual state transitions require loaded channels // This is tested in integration tests // // ğŸ’¡ actual load. // entire Integration Tests Verify. } /** * * @section _______________ âœ…: * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * @Published playbackState property Combine * value normally Verify. * * * @section combine________ ğŸ”„ Combine * @endcode * @Published var playbackState: PlaybackState =.stopped * â†“ * Publisher create * â†“ * syncController.$playbackState // $ when attached Publisher * â†“ *.sink { state in } // subscribe (subscribe) * â†“ * value * @endcode * * * @section xctestexpectation___ ğŸ’¡ XCTestExpectation? * @endcode * let expectation = expectation(description: "...") * * // Tasks (Combine subscribe) *.sink { value in * expectation.fulfill() // âœ… complete * } * * wait(for: [expectation], timeout: 1.0) // â±ï¸ 1seconds * @endcode * * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> playbackState subscribe * - <b>When:</b> subscribe (secondsvalue) * - <b>Then:</b> value.stopped * @endcode * * @test testPlaybackStatePublishing * @brief âš ï¸ timeout? * * @details * * @section __timeout________ âš ï¸ timeout? * @endcode *: 0.01seconds value â†’ and *: value â†’ 1seconds failure () * @endcode */ func testPlaybackStatePublishing() { // Given: subscribe // ğŸ¯ Tasks complete Expectation create let expectation = expectation(description: "Playback state published") // ğŸ“¦ array var receivedStates: [PlaybackState] = [] // ğŸ”„ @Published playbackState subscribe syncController.$playbackState.sink { state in // ğŸ’¡.sink: // - value // - secondsvaluealso (.stopped) // receivedStates.append(state) // 1 expectation complete (multiple fulfill) if receivedStates.count == 1 { expectation.fulfill() } }.store(in: &cancellables) // âš ï¸.store(in:): // â†’ subscribe () // â†’ value // Then: value Verify // â±ï¸ expectation fulfill 1seconds wait(for: [expectation], timeout: 1.0) // ğŸ“ value.stopped XCTAssertEqual(receivedStates.first,.stopped) } /** * * @section _______________ âœ…: * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * @Published currentTime property Combine * value normally Verify. * * â±ï¸ currentTime: * @endcode * SyncController * â”œâ”€â”€ currentTime: 3.5seconds () * â”œâ”€â”€ duration: 60.0seconds (entire) * â””â”€â”€ playbackPosition: 0.058 (3.5 / 60.0) * * UI: * currentTime â†’ Combine â†’ UI * @endcode * * * @section ____________ ğŸ”„ * @endcode *: 0.0seconds â†’ 0.033seconds â†’ 0.066seconds â†’... (30fps) * â†“ â†“ â†“ *.sink.sink.sink * â†“ â†“ â†“ * UI () * @endcode * * * @section timeinterval___ ğŸ’¡ TimeInterval? * @endcode * typealias TimeInterval = Double * * currentTime: TimeInterval = 3.5 // 3.5seconds * @endcode * * @test testCurrentTimePublishing * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> currentTime subscribe * - <b>When:</b> subscribe (secondsvalue) * - <b>Then:</b> value 0.0 * @endcode */ func testCurrentTimePublishing() { // Given: subscribe // ğŸ¯ Tasks complete Expectation let expectation = expectation(description: "Current time published") // â±ï¸ value array var receivedTimes: [TimeInterval] = [] // ğŸ”„ @Published currentTime subscribe syncController.$currentTime.sink { time in // ğŸ’¡ seconds 30 (30fps) // receivedTimes.append(time) // 1 expectation complete (multiple fulfill) if receivedTimes.count == 1 { expectation.fulfill() } }.store(in: &cancellables) // ğŸ“¦ cancellables Set subscribe // Then: secondsvalue Verify // â±ï¸ 1seconds wait(for: [expectation], timeout: 1.0) // â±ï¸ value 0.0 (initial state) XCTAssertEqual(receivedTimes.first, 0.0) } // ======================================================================== // MARK: - Playback Control Tests // ======================================================================== // // ğŸ¯ Purpose: Playback Control method(play, pause, stop, toggle) Verify. // // âœ… Verify: // - without channels also (failure) // - without channels also (failure) // - method () // - method ( initialization) /** * * @section ________________ âœ…: without channels also * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * load play() *.stopped Verify. * * * @section __________ ğŸ”„ * @endcode * 1. loadVideoFile() â†’ load â†’.paused * 2. play() â†’ â†’.playing * @endcode * * * @section __________________ âš ï¸ () * @endcode * 1. ( load) * 2. play() â†’ âŒ â†’.stopped * @endcode * * * @section __________________ ğŸ’¡? * @endcode * //: * play() // â†’ nil â†’! ğŸ’¥ * * //: * play() // â†’ Confirm â†’ Return âœ… * @endcode * * @test testPlayWithoutChannels * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> load SyncController * - <b>When:</b> play() method * - <b>Then:</b> playbackState.stopped * @endcode */ func testPlayWithoutChannels() { // When: without channels also syncController.play() // Then:.stopped // âš ï¸.stopped XCTAssertEqual( syncController.playbackState,.stopped, "Should remain stopped without channels") } /** * * @section __________________________ âœ…: also * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * pause() *.stopped Verify. * * * @section ____________ ğŸ”„ * @endcode *.playing â”€â”€pause()â”€â”€â†’.paused * @endcode * * * @section _________ âš ï¸ * @endcode *.stopped â”€â”€pause()â”€â”€â†’.stopped () * @endcode * * * @section idempotent________ ğŸ’¡ Idempotent() * @endcode * pause() also * * pause() //.stopped â†’.stopped * pause() //.stopped â†’.stopped () * @endcode * * @test testPauseWithoutPlaying * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b>.stopped SyncController * - <b>When:</b> pause() method * - <b>Then:</b> playbackState.stopped * @endcode */ func testPauseWithoutPlaying() { // When: also syncController.pause() // Then:.stopped // ğŸ’¡ XCTAssertEqual( syncController.playbackState,.stopped, "Should remain stopped") } /** * * @section _______________ âœ…: / * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * togglePlayPause() method Verify. * * * @section toggleplaypause_____ ğŸ”„ togglePlayPause() * @endcode * if playbackState ==.playing { * pause() // â†’ * } else { * play() // / â†’ * } * @endcode * * * @section ui______ ğŸ’¡ UI * @endcode * Button("â–¶ï¸/â¸ï¸") { * syncController.togglePlayPause() * } * // / * @endcode * * * @section unit_test____ âš ï¸ Unit Test * @endcode * Unit Test: * - method Confirm * - actual * * Integration Test: * - actual load Verify * -.playing â‡„.paused Confirm * @endcode * * @test testTogglePlayPause * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> SyncController * - <b>When:</b> togglePlayPause() * - <b>Then:</b> complete * @endcode */ func testTogglePlayPause() { // Note: Requires loaded channels for actual toggle // Unit test verifies method exists and doesn't crash // // ğŸ“ actual load. // Unit Test method and Verify. // When: method syncController.togglePlayPause() // Then: complete // ğŸ’¡ syncController nil method XCTAssertNotNil(syncController) } /** * * @section ________stop____ âœ…: (Stop) * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * stop() method initialization Verify. * * * @section stop______ ğŸ”„ stop() * @endcode * 1. * 2..stopped * 3. property initialization * 4. Sensor Services cleanup * @endcode * * * @section stop___vs_pause______ ğŸ’¡ stop() vs pause() * @endcode * pause(): * -.playing â†’.paused * - () * - currentTime () * - play() * * stop(): * - â†’.stopped * - ( cleanup) * - currentTime = 0.0 () * - loadVideoFile() * @endcode * * ğŸ§¹ cleanup Tasks: * @endcode * stop(): * â”œâ”€ playbackState =.stopped * â”œâ”€ currentTime = 0.0 * â”œâ”€ playbackPosition = 0.0 * â”œâ”€ duration = 0.0 * â”œâ”€ channelCount = 0 * â””â”€ VideoChannel * @endcode * * @test testStop * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> SyncController instance * - <b>When:</b> stop() method * - <b>Then:</b> secondsvalue * @endcode */ func testStop() { // When: method syncController.stop() // Then: initialization // ğŸ®.stopped XCTAssertEqual(syncController.playbackState,.stopped) // â±ï¸ 0.0 XCTAssertEqual(syncController.currentTime, 0.0) // ğŸ“ 0.0 () XCTAssertEqual(syncController.playbackPosition, 0.0) // â²ï¸ also 0.0 () XCTAssertEqual(syncController.duration, 0.0) // ğŸ“º load also 0 XCTAssertEqual(syncController.channelCount, 0) } // ======================================================================== // MARK: - Seeking Tests // ======================================================================== // // ğŸ¯ Purpose: Seeking() functionality Verify. // // âœ… Verify: // - (seekToTime) // - (seekBySeconds) // - (value) // - (clamping) /** * * @section _______________ âœ…: * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * seekToTime() method, * value (clamp) Verify. * * * @section seeking___ ğŸ¬ Seeking? * @endcode *: * [========â—====================] 60seconds * â†‘ *: 10seconds * * seekToTime(30.0): * [==========================â—==] 60seconds * â†‘ *: 30seconds * @endcode * * * @section _____seeking___ ğŸ”„ Seeking * @endcode * 1. load (duration = 60.0seconds) * 2. seekToTime(30.0) * 3. currentTime = 30.0 * 4. 30seconds * 5. * @endcode * * * @section clamping________ âš ï¸ Clamping () * @endcode * // duration = 60seconds * seekToTime(-10.0) â†’ 0.0 (value) * seekToTime(30.0) â†’ 30.0 () * seekToTime(100.0) â†’ 60.0 (value) * @endcode * * * @section __unit_test____ ğŸ’¡ Unit Test * @endcode * duration = 0 () * seekToTime(5.0) * â†’ 0...0 clamp * â†’ currentTime = 0.0 * @endcode * * @test testSeekToTime * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> SyncController (duration = 0) * - <b>When:</b> seekToTime(5.0) * - <b>Then:</b> currentTime 0.0 * @endcode */ func testSeekToTime() { // Note: Requires loaded channels // Unit test verifies method exists // // ğŸ“ actual Seeking load. // Unit Test (clamping) Verify. // When: 5.0seconds also syncController.seekToTime(5.0) // Then: Should clamp to 0.0 since duration is 0 // âš ï¸ duration 0 0...0 // â†’ 5.0 0.0 XCTAssertEqual(syncController.currentTime, 0.0) } /** * * @section ______________ âœ…: * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * seekBySeconds() method * Verify. * * * @section seektotime_vs_seekbyseconds ğŸ”„ seekToTime vs seekBySeconds * @endcode *: 10seconds * * seekToTime(30.0): * - * - 10seconds â†’ 30seconds * * seekBySeconds(+20.0): * - * - 10seconds + 20seconds = 30seconds * * seekBySeconds(-5.0): * - * - 10seconds - 5seconds = 5seconds * @endcode * * * @section ui______ ğŸ’¡ UI * @endcode * Button("âª 10seconds ") { * syncController.seekBySeconds(-10.0) * } * * Button("â© 10seconds ") { * syncController.seekBySeconds(+10.0) * } * @endcode * * * @section _____ ğŸ”„ * @endcode * func seekBySeconds(_ offset: Double) { * let newTime = currentTime + offset * seekToTime(newTime) // seekToTime * } * @endcode * * * @section __unit_test____ âš ï¸ Unit Test * @endcode * currentTime = 0.0 (secondsvalue) * duration = 0.0 () * * seekBySeconds(10.0) * â†’ newTime = 0.0 + 10.0 = 10.0 * â†’ seekToTime(10.0) * â†’ 0...0 clamp â†’ 0.0 * @endcode * * @test testSeekBySeconds * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> currentTime = 0, duration = 0 * - <b>When:</b> seekBySeconds(10.0) * - <b>Then:</b> currentTime 0.0 * @endcode */ func testSeekBySeconds() { // When: 10seconds also syncController.seekBySeconds(10.0) // Then: Should seek from current time // With duration 0, should clamp to 0 // ğŸ’¡: // newTime = currentTime(0.0) + offset(10.0) = 10.0 // â†’ duration 0 0.0 XCTAssertEqual(syncController.currentTime, 0.0) } /** * * @section _____________ âœ…: * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * seekToTime() 0 Verify. * * ğŸ”’ value (Boundary Testing): * @endcode *: 0 â‰¤ time â‰¤ duration * * value: * â”œâ”€ time < 0 ( secondsand) â†’ 0 * â”œâ”€ time = 0 () â†’ * â”œâ”€ time = duration () â†’ * â””â”€ time > duration ( secondsand) â†’ duration * @endcode * * * @section ______________ âš ï¸ * @endcode * // use: * currentTime = 3.0 * seekBySeconds(-10.0) * â†’ newTime = 3.0 - 10.0 = -7.0 âŒ * â†’ seekToTime(-7.0) * â†’ 0.0 âœ… * @endcode * * * @section _________ ğŸ’¡ * @endcode * //: * seekToTime(-5.0) * â†’ videoChannel.seek(-5.0) * â†’ FFmpeg error! ğŸ’¥ * * //: * seekToTime(-5.0) * â†’ clamp(-5.0, 0...60) = 0.0 * â†’ videoChannel.seek(0.0) âœ… * @endcode * * @test testSeekNegativeTime * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> SyncController instance * - <b>When:</b> seekToTime(-5.0) () * - <b>Then:</b> currentTime 0.0 * @endcode */ func testSeekNegativeTime() { // When: also syncController.seekToTime(-5.0) // Then: Should clamp to 0 // ğŸ”’ value 0.0 XCTAssertEqual(syncController.currentTime, 0.0) } // ======================================================================== // MARK: - Synchronized Frames Tests // ======================================================================== // // ğŸ¯ Purpose: channel synchronization functionality Verify. // // âœ… Verify: // - getSynchronizedFrames() method // - getBufferStatus() method // - /** * * @section _____________________ âœ…: without channels frame query * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * getSynchronizedFrames() empty Return * Verify. * * * @section __________ ğŸ”„ frame? * @endcode *: * *: 3.5seconds * * front: [frame @ 3.498seconds] â”€â” * rear: [frame @ 3.502seconds] â”€â”¼â”€â†’ * side: [frame @ 3.500seconds] â”€â”˜ * â†“ * getSynchronizedFrames() Return: * [ *.front: VideoFrame @ 3.498seconds, *.rear: VideoFrame @ 3.502seconds, *.left: VideoFrame @ 3.500seconds * ] * @endcode * * * @section ________ ğŸ’¡ * @endcode *: each frame * (,) * *: SyncController Â±50ms within frame * " " Display on screen * @endcode * * * @section _____ ğŸ” Return * @endcode * [CameraPosition: VideoFrame] * * //: * [ *.front: frame1, *.rear: frame2 * ] * @endcode * * * @section ________ âš ï¸ * @endcode * let frames = getSynchronizedFrames() * frames.isEmpty // true * @endcode * * @test testGetSynchronizedFramesWithNoChannels * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> SyncController * - <b>When:</b> getSynchronizedFrames() * - <b>Then:</b> empty Return * @endcode */ func testGetSynchronizedFramesWithNoChannels() { // When: frame query let frames = syncController.getSynchronizedFrames() // Then: empty // ğŸ“¦ framealso XCTAssertTrue( frames.isEmpty, "Should return empty dictionary without channels") } /** * * @section ___________________ âœ…: without channels query * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * getBufferStatus() empty Return * Verify. * * ğŸ“¦? * @endcode * each frame: * * front: * [Frame][Frame][Frame]...[Frame] 25/30 (83%) * * rear: * [Frame][Frame][Frame][Frame]... 28/30 (93%) * * getBufferStatus() Return: * [ *.front: BufferStatus(current: 25, maximum: 30, fillPercentage: 0.83), *.rear: BufferStatus(current: 28, maximum: 30, fillPercentage: 0.93) * ] * @endcode * * * @section _________ ğŸ’¡ * @endcode * UI: * [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘] 83% - front * [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘] 93% - rear * *: * - â†’ decoding * - â†’ * @endcode * * * @section _____ ğŸ” Return * @endcode * [CameraPosition: BufferStatus] * * struct BufferStatus { * let current: Int // * let maximum: Int // * let fillPercentage: Double // 0.0 ~ 1.0 * } * @endcode * * * @section ________ âš ï¸ * @endcode * let status = getBufferStatus() * status.isEmpty // true * @endcode * * @test testGetBufferStatusWithNoChannels * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> SyncController * - <b>When:</b> getBufferStatus() * - <b>Then:</b> empty Return * @endcode */ func testGetBufferStatusWithNoChannels() { // When: query let status = syncController.getBufferStatus() // Then: empty // ğŸ“¦ also XCTAssertTrue( status.isEmpty, "Should return empty dictionary without channels") } // ======================================================================== // MARK: - Time Formatting Tests // ======================================================================== // // ğŸ¯ Purpose: time formatting functionality Verify. // // âœ… Verify: // - currentTimeString () // - durationString () // - remainingTimeString () // - playbackSpeedString ( also) // - value /** * * @section ______________ âœ…: * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * currentTimeString Verify. * * ğŸ•: * @endcode * MM:SS (:seconds) * *: * 0seconds â†’ "00:00" * 30seconds â†’ "00:30" * 90seconds â†’ "01:30" * 3665seconds â†’ "61:05" (61 5seconds) * @endcode * * * @section __hh_mm_ss_____mm_ss____ ğŸ’¡ HH:MM:SS MM:SS? * @endcode * 1~3: * - 00:00:30 ( 00:) * - 00:30 () âœ… * * 60: * - 01:30:00 () * - 90:00 (90) âœ… * @endcode * * * @section _____ ğŸ”„ * @endcode * let totalSeconds = Int(currentTime) * let minutes = totalSeconds / 60 // 90 / 60 = 1 * let seconds = totalSeconds % 60 // 90 % 60 = 30 * return String(format: "%02d:%02d", minutes, seconds) * // â†’ "01:30" * @endcode * * @test testCurrentTimeString * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> currentTime = 0.0 * - <b>When:</b> currentTimeString property * - <b>Then:</b> "00:00" Return * @endcode */ func testCurrentTimeString() { // Given: currentTime = 0 // (setUp() initialization) // When: query let timeString = syncController.currentTimeString // Then: "00:00" XCTAssertEqual(timeString, "00:00") } /** * * @section ________________ âœ…: * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * durationString Verify. * * ğŸ• duration: * @endcode * entire: * * [â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”] 3:00 â† durationString * â†‘ â†‘ * 0seconds 180seconds * @endcode * * * @section ui______ ğŸ’¡ UI * @endcode * Text(": \(syncController.durationString)") * // â†’ ": 03:00" * * //: * [â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘] 01:30 / 03:00 * â†‘ â†‘ * current duration * @endcode * * @test testDurationString * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> duration = 0.0 () * - <b>When:</b> durationString property * - <b>Then:</b> "00:00" Return * @endcode */ func testDurationString() { // Given: duration = 0 // ( load) // When: query let durationString = syncController.durationString // Then: "00:00" XCTAssertEqual(durationString, "00:00") } /** * * @section ______________ âœ…: * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * remainingTimeString Verify. * * ğŸ•: * @endcode * remaining = duration - currentTime * *: * duration = 180seconds (3) * currentTime = 90seconds (1 30seconds) * remaining = 180 - 90 = 90seconds (1 30seconds) * â†’ "-01:30" ( -) * @endcode * * * @section ________________ ğŸ’¡ (-)? * @endcode * UI: * - " " - * * [â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘] 01:30 / 03:00 (-01:30) * â†‘ â†‘ â†‘ * entire * @endcode * * * @section _____ ğŸ”„ * @endcode * let remaining = duration - currentTime // 90.0 * let formatted = formatTime(remaining) // "01:30" * return "-\(formatted)" // "-01:30" * @endcode * * @test testRemainingTimeString * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> duration = 0, currentTime = 0 * (remaining = 0) * - <b>When:</b> remainingTimeString property * - <b>Then:</b> "-00:00" Return * @endcode */ func testRemainingTimeString() { // Given: remaining = 0 // (duration - currentTime = 0 - 0 = 0) // When: query let remainingString = syncController.remainingTimeString // Then: "-00:00" () XCTAssertEqual(remainingString, "-00:00") } /** * * @section ______________ âœ…: also * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * playbackSpeedString Verify. * * * @section ________ âš¡ also * @endcode * 0.5x â†’ () * 1.0x â†’ also * 1.5x â†’ 1.5 (fast) * 2.0x â†’ 2 * @endcode * * * @section ui______ ğŸ’¡ UI * @endcode * Button(syncController.playbackSpeedString) { * // also * } * // â†’ "1.5x" * * //: * Text(" also: \(syncController.playbackSpeedString)") * // â†’ " also: 1.5x" * @endcode * * * @section ___ ğŸ”„ * @endcode * playbackSpeed = 1.5 * return "\(playbackSpeed)x" // "1.5x" * * playbackSpeed = 1.0 * return "\(playbackSpeed)x" // "1.0x" * @endcode * * @test testPlaybackSpeedString * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> playbackSpeed 1.5 * - <b>When:</b> playbackSpeedString property * - <b>Then:</b> "1.5x" Return * @endcode */ func testPlaybackSpeedString() { // Given: also 1.5 syncController.playbackSpeed = 1.5 // When: also query let speedString = syncController.playbackSpeedString // Then: "1.5x" XCTAssertEqual(speedString, "1.5x") } /** * * @section ________________ âœ…: value * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * value correctly Verify. * * * @section _______ ğŸ“Š * @endcode * 0seconds â†’ "00:00" (0 0seconds) * 30seconds â†’ "00:30" (0 30seconds) * 60seconds â†’ "01:00" (1 0seconds) * 90seconds â†’ "01:30" (1 30seconds) * 3600seconds â†’ "60:00" (60 0seconds) * 3665seconds â†’ "61:05" (61 5seconds) * @endcode * * * @section ________ ğŸ’¡ * @endcode * func formatTime(_ seconds: TimeInterval) -> String { * let total = Int(seconds) * let min = total / 60 // * let sec = total % 60 // * return String(format: "%02d:%02d", min, sec) * } * * //: 3665seconds * // min = 3665 / 60 = 61 * // sec = 3665 % 60 = 5 * // â†’ "61:05" * @endcode * * * @section _02d_______ ğŸ” %02d * @endcode * %02d = 2, empty 0 * * 5 â†’ "%02d" â†’ "05" * 30 â†’ "%02d" â†’ "30" * 100 â†’ "%02d" â†’ "100" (2) * @endcode * * @test testTimeFormatting * @brief ğŸ“ Note: * * @details * * @section note ğŸ“ Note * private method, * Swift private method. * Integration Tests public API Verify. */ func testTimeFormatting() { // Test various time values let testCases: [(TimeInterval, String)] = [ (0, "00:00"), // 0seconds (30, "00:30"), // 30seconds (60, "01:00"), // 1 (90, "01:30"), // 1 30seconds (3600, "60:00"), // 60 (3665, "61:05") // 61 5seconds ] // ğŸ’¡ each Expected Result for (time, expected) in testCases { // Use private method through reflection or test computed property // For now, test through public API // // ğŸ“ Swift private method // â†’ Integration Tests actual Verify // // internal: // @testable import internal can access } } // ======================================================================== // MARK: - Playback Speed Tests // ======================================================================== // // ğŸ¯ Purpose: also functionality Verify. // // âœ… Verify: // - also Combine // - Drift threshold () /** * * @section _____________ âœ…: also * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * playbackSpeed property Combine * value normally Verify. * * * @section ____________ âš¡ also and * @endcode * 1.0x (): * - 1seconds actual 1seconds * - 30fps â†’ seconds 30frame * * 0.5x (): * - 1seconds actual 2seconds * - 30fps â†’ seconds 15frame * * 2.0x (): * - 1seconds actual 0.5seconds * - 30fps â†’ seconds 60frame * @endcode * * * @section ________ ğŸ”„ also * @endcode * UI also: * syncController.playbackSpeed = 2.0 * â†“ * @Published value * â†“ *.sink { speed in } // subscribe * â†“ * each VideoChannel decoding Speed Control * â†“ * also * @endcode * * * @section _________ ğŸ’¡ also * @endcode * // also also * syncController.play() * syncController.playbackSpeed = 1.5 // * // â†’ 1.5 * @endcode * * @test testPlaybackSpeedChange * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> playbackSpeed subscribe * - <b>When:</b> playbackSpeed 2.0 * - <b>Then:</b> secondsvalue(1.0)and value(2.0) * @endcode */ func testPlaybackSpeedChange() { // Given: also subscribe // ğŸ¯ Tasks complete Expectation let expectation = expectation(description: "Playback speed changed") // âš¡ also value array var receivedSpeeds: [Double] = [] // ğŸ”„ @Published playbackSpeed subscribe syncController.$playbackSpeed.sink { speed in // ğŸ’¡ value: // 1. secondsvalue 1.0 (subscribe) // 2. value 2.0 () // also receivedSpeeds.append(speed) // 2 expectation complete if receivedSpeeds.count >= 2 { expectation.fulfill() } }.store(in: &cancellables) // When: also 2 syncController.playbackSpeed = 2.0 // Then: value Verify // â±ï¸ 1seconds wait(for: [expectation], timeout: 1.0) // âš¡ value 2.0 XCTAssertEqual(receivedSpeeds.last, 2.0) // ğŸ’¡ entire value: [1.0, 2.0] // -: secondsvalue (setUp) // -: value () } /** * * @section _____drift_threshold____________ âœ…: Drift Threshold () * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * Drift threshold 50ms Confirm. * * * @section drift__ ğŸ”„ Drift? * @endcode * channel synchronization: * *: 3.500seconds * * front: frame @ 3.498seconds (drift: -2ms) âœ… * rear: frame @ 3.530seconds (drift: +30ms) âœ… * side: frame @ 3.555seconds (drift: +55ms) âŒ secondsand * * Drift Threshold = 50ms * â†’ Â±50ms within frame "" * @endcode * * * @section __drift________ ğŸ’¡ Drift? * @endcode *: * 1. * 2. and * 3. I-Frameand P-Frame * 4. (IP) * @endcode * * * @section 50ms________ ğŸ¯ 50ms * @endcode * each: * - 20ms: * - 20~50ms: () * - 50ms: * * 30fps: * - frame: 33ms * - 50ms = 1.5frame * - 2frame * @endcode * * ğŸ”§ Drift: * @endcode * func getSynchronizedFrames() -> [CameraPosition: VideoFrame] { * let targetTime = currentTime * * for channel in channels { * let frame = channel.getFrame(at: targetTime) * * // Drift Confirm * let drift = abs(frame.timestamp - targetTime) * if drift > driftThreshold { // 50ms * // frame * continue * } * * frames[channel.position] = frame * } * } * @endcode * * @test testDriftThreshold * @brief ğŸ“ Note: * * @details * * @section note ğŸ“ Note * driftThreshold internal property, * Integration Tests actual Verify. */ func testDriftThreshold() { // Drift threshold should be 50ms // This is an internal property, tested through integration // // ğŸ“ Drift threshold 50ms (0.05seconds). // // ğŸ’¡ value SyncController internal property: // ```swift // private let driftThreshold: TimeInterval = 0.05 // 50ms // ``` // // ğŸ” actual Integration Tests Verify: // - actual file load // - channel synchronization // - each drift // - 50ms within Confirm } // ======================================================================== // MARK: - Thread Safety Tests // ======================================================================== // // ğŸ¯ Purpose: Verify. // // âœ… Verify: // - (channelCount, allChannelsReady) // - frame (getSynchronizedFrames, getBufferStatus) // - complete /** * * @section ________________ âœ…: information * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * information also * Verify. * * ğŸ”’ Thread safety? * @endcode * data also * data * *: * Thread 1: channelCount read â†’ 3 * Thread 2: channels array â†’ [ch1, ch2] * Thread 1: channels[2] â†’ âŒ Index out of range! * @endcode * * ğŸ”§ Thread safety: * @endcode * 1. NSLock use: * let lock = NSLock() * lock.lock() * defer { lock.unlock() } * // * * 2. DispatchQueue use: * let queue = DispatchQueue(label: "sync") * queue.sync { * // * } * * 3. Actor (Swift 5.5+): * actor SyncController { * // Thread safety * } * @endcode * * ğŸ§ª DispatchQueue.concurrentPerform? * @endcode * DispatchQueue.concurrentPerform(iterations: 100) { i in * // 100 * } * *: * - GCD * - * - * @endcode * * * @section __________ ğŸ’¡ actual use Scenario * @endcode *: * * UI Thread: syncController.channelCount * Decoding Thread: videoChannel.decode() * Network Thread: gpsService.update() * â†“ * SyncController data * â†“ * Thread safety! * @endcode * * @test testConcurrentChannelAccess * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> SyncController instance * - <b>When:</b> 100 information * - <b>Then:</b> complete * @endcode */ func testConcurrentChannelAccess() { // When: Access channel count from multiple threads // ğŸ”„ 100 DispatchQueue.concurrentPerform(iterations: 100) { _ in // ğŸ“º read (read) _ = syncController.channelCount // âœ… Confirm (read) _ = syncController.allChannelsReady // ğŸ’¡ property 100 // â†’ complete } // Then: Should not crash // ğŸ’¡ syncController nil complete XCTAssertNotNil(syncController) // ğŸ“ Note: actual also //. // Thread Sanitizer use } /** * * @section ______________ âœ…: frame * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * frame data also * Verify. * * ğŸ“¦ method: * @endcode * getSynchronizedFrames(): * - all channels frame query * - Dictionary Return (read) * * getBufferStatus(): * - all channels query * - Dictionary Return (read) * @endcode * * * @section ________________ ğŸ’¡ frame? * @endcode * actual: * * Render Thread: getSynchronizedFrames() // 60fps * UI Thread: getBufferStatus() // seconds * Export Thread: getSynchronizedFrames() // 30fps * * â†’ seconds! * â†’ Thread safety * @endcode * * ğŸ”’ data: * @endcode * // SyncController * private var channels: [VideoChannel] = [] // â† * private var currentFrames: [CameraPosition: VideoFrame] = [:] * * //: * func getSynchronizedFrames() -> [CameraPosition: VideoFrame] { * lock.lock() * defer { lock.unlock() } * return currentFrames * } * @endcode * * * @section race_condition___ âš ï¸ Race Condition * @endcode *: * * Thread A: Thread B: * frames = getSynced() frames = getSynced() * â†“ â†“ * for (pos, frame) in frames * â†“ channels.removeAll() * frame.render() â†“ * â†“ ğŸ’¥ frames! * âŒ! * @endcode * * @test testConcurrentFrameAccess * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> SyncController instance * - <b>When:</b> 100 frame/ query * - <b>Then:</b> query complete * @endcode */ func testConcurrentFrameAccess() { // When: Get synchronized frames from multiple threads // ğŸ”„ 100 DispatchQueue.concurrentPerform(iterations: 100) { _ in // ğŸ¬ frame query _ = syncController.getSynchronizedFrames() // ğŸ“Š query _ = syncController.getBufferStatus() // ğŸ’¡ method 100 // â†’ channels array // â†’ complete } // Then: Should not crash // ğŸ’¡ complete Confirm XCTAssertNotNil(syncController) // ğŸ“ Verify: // - Thread Sanitizer data // - Instruments Confirm // - Stress Test } // ======================================================================== // MARK: - Memory Management Tests // ======================================================================== // // ğŸ¯ Purpose: Memory management correctly Verify. // // âœ… Verify: // - deinit () // - stop() method cleanup // - /** * * @section _____deinit______ âœ…: deinit Confirm * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * SyncController nil normally * Verify. * * ğŸ§  ARC (Automatic Reference Counting)? * @endcode * Swift Memory management: * * 1. object create: * let controller = SyncController() * â†’ Reference Count: 1 * * 2.: * let another = controller * â†’ Reference Count: 2 * * 3.: * controller = nil * â†’ Reference Count: 1 * * 4.: * another = nil * â†’ Reference Count: 0 * â†’ deinit * â†’ * @endcode * * * @section deinit____ ğŸ’¡ deinit * @endcode * class SyncController { * deinit { * // * // 1. * // 2. file * // 3. * // 4. * } * } * @endcode * * * @section _________ âš ï¸ * @endcode * // (Retain Cycle): * class A { * var b: B? * } * class B { * var a: A? // * } * let a = A() * let b = B() * a.b = b * b.a = a //! * a = nil * b = nil * // â†’ deinit! ğŸ’¥ * * //: weak unowned use * class B { * weak var a: A? // âœ… * } * @endcode * * * @section _____________ ğŸ” Confirm * @endcode * 1. controller = nil * 2. 0 * 3. deinit * 4. actual * @endcode * * @test testDeinit * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> SyncController instance create ( 1) * - <b>When:</b> nil ( 0) * - <b>Then:</b> (controller nil) * @endcode */ func testDeinit() { // Given: SyncController instance create // ğŸ’¡ nil can var controller: SyncController? = SyncController() //: 1 // When: nil controller = nil //: 0 â†’ deinit â†’ // Then: nil // ğŸ’¡ controller nil XCTAssertNil(controller) // ğŸ“ Confirm available: // - Instruments Leaks also Confirm // - deinit print Confirm // - } /** * * @section _____stop__________ âœ…: stop() cleanup * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * stop() method cleanup Verify. * * ğŸ§¹ stop() method cleanup Tasks: * @endcode * 1.: * - playbackState =.stopped * - * * 2. cleanup: * - VideoChannel * - channels array * - channelCount = 0 * * 3. initialization: * - currentTime = 0.0 * - duration = 0.0 * - playbackPosition = 0.0 * * 4. Sensor Services cleanup: * - GPS data cleanup * - G-Sensor data cleanup * @endcode * * * @section stop___vs_deinit___ ğŸ’¡ stop() vs deinit * @endcode * stop(): * - * - cleanup + initialization * - object * - loadVideoFile() * * deinit: * - (ARC) * - * - object * - use * @endcode * * * @section __________ ğŸ”„ use * @endcode * // 1 * syncController.loadVideoFile(video1) * syncController.play() * * // * syncController.stop() // cleanup * syncController.loadVideoFile(video2) // load * syncController.play() * * // * syncController = nil // deinit * @endcode * * * @section stop____________ âš ï¸ stop() * @endcode * loadVideoFile(video2) // stop() load * â†’ VideoChannel * â†’! * â†’ decoding * @endcode * * @test testStopClearsResources * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> SyncController instance * - <b>When:</b> stop() method * - <b>Then:</b> secondsvalue * @endcode */ func testStopClearsResources() { // When: stop() method syncController.stop() // Then: cleanup // ğŸ“º 0 initialization XCTAssertEqual(syncController.channelCount, 0) // â±ï¸ 0.0 initialization XCTAssertEqual(syncController.currentTime, 0.0) // â²ï¸ 0.0 initialization XCTAssertEqual(syncController.duration, 0.0) // ğŸ’¡ Confirm: // - playbackState ==.stopped // - playbackPosition == 0.0 // - allChannelsReady == false // - getSynchronizedFrames().isEmpty == true // - getBufferStatus().isEmpty == true } // ======================================================================== // MARK: - Performance Tests // ======================================================================== // // ğŸ¯ Purpose: Confirm. // // âœ… Verify: // - getSynchronizedFrames() // - getBufferStatus() // - 1000 /** * * @section _____getsynchronizedframes_____ âœ…: getSynchronizedFrames() * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * getSynchronizedFrames() method 1000 *. * * â±ï¸ measure {}? * @endcode * measure { * // 10 * // each * //, * } * * and: * 1: 0.015seconds * 2: 0.014seconds * 3: 0.016seconds *... * 10: 0.015seconds * â†“ *: 0.015seconds Â± 0.001seconds * â†“ * Xcode Baseline * @endcode * * * @section _____ ğŸ“Š * @endcode *: 1000 < 10ms * *: * - 60fps = 16.67ms per frame * - getSynchronizedFrames() frame * - 1 < 0.01ms * - 1000 < 10ms * * result: * * @section 5ms___________________ âœ… 5ms â†’ () * * @section 15ms______________ âš ï¸ 15ms â†’ () * âŒ 50ms â†’ () * @endcode * * * @section __________ ğŸ’¡ * @endcode * //: * func getSynchronizedFrames() -> [CameraPosition: VideoFrame] { * var result: [CameraPosition: VideoFrame] = [:] * for channel in channels { * let frame = channel.decode() // âŒ decoding * result[channel.position] = frame * } * return result * } * * // fast: * func getSynchronizedFrames() -> [CameraPosition: VideoFrame] { * return currentFrames // âœ… frame Return * } * @endcode * * * @section xcode_baseline___ ğŸ” Xcode Baseline functionality * @endcode * 1. * 2. "Set Baseline" * 3. Baselineand * 4. 10% * @endcode * * @test testGetSynchronizedFramesPerformance * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> SyncController instance () * - <b>When:</b> getSynchronizedFrames() 1000 * - <b>Then:</b> within * @endcode */ func testGetSynchronizedFramesPerformance() { // â±ï¸ measure Performance measurement measure { // ğŸ’¡ 1000 for _ in 0..<1000 { // ğŸ¬ frame query _ = syncController.getSynchronizedFrames() // ğŸ“ Note: empty Return // â†’ // â†’ Integration Tests actual } } // ğŸ’¡ measure: // - Xcode Test Navigator // - Baselineand () // - } /** * * @section _____getbufferstatus_____ âœ…: getBufferStatus() * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * getBufferStatus() method 1000 *. * * * @section _____ ğŸ“Š * @endcode *: 1000 < 10ms * *: * - UI use (seconds 1~10) * - (,) * - UI fast * @endcode * * * @section ___________ ğŸ’¡ * @endcode * func getBufferStatus() -> [CameraPosition: BufferStatus] { * var result: [CameraPosition: BufferStatus] = [:] * for channel in channels { * let status = BufferStatus( * current: channel.buffer.count, // O(1) * maximum: channel.buffer.capacity, // O(1) * fillPercentage: Double(channel.buffer.count) / * Double(channel.buffer.capacity) // O(1) *) * result[channel.position] = status * } * return result // O(n), n = * } * @endcode * * * @section ______ ğŸ¯ * @endcode * 1.: * - * - value Return * * 2. Lazy: * - * - use * * 3.: * - * - DispatchQueue.concurrentPerform use * @endcode * * @test testGetBufferStatusPerformance * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> SyncController instance () * - <b>When:</b> getBufferStatus() 1000 * - <b>Then:</b> within * @endcode */ func testGetBufferStatusPerformance() { // â±ï¸ measure Performance measurement measure { // ğŸ’¡ 1000 for _ in 0..<1000 { // ğŸ“Š query _ = syncController.getBufferStatus() // ğŸ“ Note: empty Return // â†’ method // â†’ actual Integration Tests Confirm } } // ğŸ’¡: // - getSynchronizedFrames() () // - lock // - Thread Sanitizer Confirm } } // ============================================================================ // MARK: - Integration Tests // ============================================================================ /// ğŸ”— SyncControllerIntegrationTests /// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ /// actual fileand use SyncController entire /// Verify Integration Test. /// /// ğŸ“ Unit Tests vs Integration Tests: /// ``` /// Unit Tests (SyncControllerTests): /// â”œâ”€ without channels independently /// â”œâ”€ fast (< 1seconds) /// â”œâ”€ method Verify /// â””â”€ Mock data use /// /// Integration Tests (this class): /// â”œâ”€ actual file load /// â”œâ”€ ( seconds) /// â”œâ”€ entire Verify /// â””â”€ actual data use /// ``` /// /// ğŸ¯ Test Scope: /// ``` /// 1. file load /// 2. (.paused â†’.playing â†’.paused) /// 3. Seeking /// 4. channel synchronization /// 5. playback speed control /// 6. Confirm /// 7. (.playing â†’.stopped) /// ``` /// /// âš ï¸ XCTSkip? /// ```swift /// guard let videoPath =... else { /// throw XCTSkip("Test video file not found") /// } /// ///: /// - (failure) /// - CI/CD /// - result "Skipped" /// ``` final class SyncControllerIntegrationTests: XCTestCase { // ======================================================================== // MARK: - Properties // ======================================================================== /** * ğŸ“¦ Test target SyncController instance */ var syncController: SyncController! /** * * @section ______________ ğŸ¬ file information * @endcode * VideoFile: * - actual file path * - information (front) * - data (duration, size) * @endcode */ var testVideoFile: VideoFile! // ======================================================================== // MARK: - Setup & Teardown // ======================================================================== /** * ğŸ”§ setUp method * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * each fileand SyncController. * * ğŸ“¦ Bundle? * @endcode * let bundle = Bundle(for: type(of: self)) * *: * - * - test_video.mp4 file * - path * @endcode * * * @section _____________ ğŸ¬ file * @endcode * test_video.mp4 * â”œâ”€ front (Front Camera) * â”œâ”€: 10seconds * â”œâ”€ also: 1920x1080 * â””â”€ frame: 30fps * @endcode * * * @section xctskip___ âš ï¸ XCTSkip use * @endcode * file: * - failure âŒ ( also) * - Skip âœ… () * @endcode */ override func setUpWithError() throws { super.setUp() // Create test video file // ğŸ“¦ let bundle = Bundle(for: type(of: self)) // ğŸ¬ file path guard let videoPath = bundle.path(forResource: "test_video", ofType: "mp4") else { // âš ï¸ file throw XCTSkip("Test video file not found") // ğŸ’¡ XCTSkip throw: // - "Skipped" // - // - CI/CD and } // Create test video file with channels // ğŸ¬ VideoFile instance create testVideoFile = VideoFile( id: UUID(), // ID timestamp: Date(), // create eventType:.normal, // duration: 10.0, // 10seconds channels: [ // front 1 ChannelInfo( position:.front, // front filePath: videoPath, // actual file path width: 1920, // Full HD height: 1080, // Full HD frameRate: 30.0 // 30 fps) ], metadata: VideoMetadata.empty, // empty data basePath: videoPath // path) // ğŸ”§ SyncController create syncController = SyncController() } /** * ğŸ§¹ tearDown method * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * each cleanup. * * ğŸ§¹ cleanup: * @endcode * 1. syncController.stop() â†’, * 2. syncController = nil â†’ * 3. testVideoFile = nil â†’ file information * 4. super.tearDown() â†’ cleanup * @endcode */ override func tearDownWithError() throws { // ğŸ® cleanup syncController.stop() // ğŸ—‘ï¸ syncController = nil testVideoFile = nil // ğŸ§¹ cleanup super.tearDown() } // ======================================================================== // MARK: - Integration Test Cases // ======================================================================== /** * * @section ______________ âœ…: file load * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * actual file load normally initialization * Verify. * * * @section loadvideofile_____ ğŸ”„ loadVideoFile() * @endcode * 1. VideoFile information read * 2. each VideoChannel create * - FFmpeg decoder initialization * - file * - data read * 3. duration () * 4. playbackState =.paused * 5. allChannelsReady = true * @endcode * * @test testLoadVideoFile * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> file * - <b>When:</b> loadVideoFile() * - <b>Then:</b>.paused, /duration * @endcode */ func testLoadVideoFile() throws { // When: file load try syncController.loadVideoFile(testVideoFile) // Then: load Verify // ğŸ®.paused ( complete) XCTAssertEqual(syncController.playbackState,.paused) // ğŸ“º 1 load XCTAssertGreaterThan(syncController.channelCount, 0) // â²ï¸ (> 0seconds) XCTAssertGreaterThan(syncController.duration, 0) // âœ… complete XCTAssertTrue(syncController.allChannelsReady) } /** * * @section _____________ âœ…: entire * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * â†’ entire Verify. * * * @section _____ ğŸ”„ * @endcode *.stopped * â†“ loadVideoFile() *.paused ( complete) * â†“ play() *.playing (, currentTime) * â†“ pause() *.paused (, currentTime) * @endcode * * @test testPlaybackFlow * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> load * - <b>When:</b> play() â†’ 0.5seconds â†’ pause() * - <b>Then:</b>, Confirm * @endcode */ func testPlaybackFlow() throws { // Given: load try syncController.loadVideoFile(testVideoFile) // When: Play // ğŸ® syncController.play() // Then: Confirm // ğŸ®.playing XCTAssertEqual(syncController.playbackState,.playing) // Wait for some playback // â±ï¸ 0.5seconds ( also) Thread.sleep(forTimeInterval: 0.5) // Then: Time should advance // â±ï¸ 0 () XCTAssertGreaterThan(syncController.currentTime, 0.0) // When: Pause // â¸ï¸ syncController.pause() // Then: Confirm // ğŸ®.paused XCTAssertEqual(syncController.playbackState,.paused) } /** * * @section __________seeking âœ…: Seeking * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * functionality Verify. * * * @section seeking___ ğŸ¬ Seeking * @endcode * (3.0seconds): * [====â—===============] 10seconds * * seekToTime(5.0): * [=========â—==========] 10seconds * 5.0seconds * *: * - currentTime = 5.0 * - playbackPosition = 0.5 * - 5seconds * - * @endcode * * @test testSeekDuringPlayback * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> * - <b>When:</b> seekToTime(5.0) * - <b>Then:</b> currentTime 5.0 * @endcode */ func testSeekDuringPlayback() throws { // Given: load try syncController.loadVideoFile(testVideoFile) syncController.play() // â±ï¸ 0.3seconds (seek seconds) Thread.sleep(forTimeInterval: 0.3) // When: 5seconds syncController.seekToTime(5.0) // Then: Seeking result Verify // â±ï¸ 5.0seconds XCTAssertEqual(syncController.currentTime, 5.0) // ğŸ“ 0 (5.0 / 10.0 = 0.5) XCTAssertGreaterThan(syncController.playbackPosition, 0.0) } /** * * @section ________________ âœ…: frame query * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * channel synchronization Verify. * * * @section _______ ğŸ”„ frame * @endcode *: 3.5seconds * * front: * [...frame @ 3.498seconds...] â† drift: -2ms âœ… * * getSynchronizedFrames() Return: * [ *.front: VideoFrame(timestamp: 3.498) * ] * @endcode * * @test testSynchronizedFrames * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> * - <b>When:</b> getSynchronizedFrames() * - <b>Then:</b> each frame Return * @endcode */ func testSynchronizedFrames() throws { // Given: load try syncController.loadVideoFile(testVideoFile) syncController.play() // â±ï¸ 0.5seconds (frame) Thread.sleep(forTimeInterval: 0.5) // When: frame query let frames = syncController.getSynchronizedFrames() // Then: frame Verify // ğŸ“¦ frame XCTAssertFalse(frames.isEmpty, "Should have synchronized frames") // ğŸ¬ each frame Verify for (position, frame) in frames { // â±ï¸ 0 XCTAssertGreaterThanOrEqual(frame.timestamp, 0.0) // ğŸ“ ( Confirm) print("Channel \(position.displayName): frame at \(frame.timestamp)s") } } /** * * @section _____________ âœ…: playback speed control * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * 2 actual Verify. * * * @section ________ âš¡ also * @endcode * playbackSpeed = 2.0 (2) * actual: 0.5seconds *: 0.5seconds Ã— 2.0 = 1.0seconds * *: * startTime = 0.0 * (0.5seconds) * endTime â‰ˆ 1.0seconds * elapsed = 1.0 - 0.0 = 1.0seconds * * Verify: elapsed > 0.8 () * @endcode * * @test testPlaybackSpeedControl * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> load, 2 * - <b>When:</b> 0.5seconds * - <b>Then:</b> 1seconds (2 and) * @endcode */ func testPlaybackSpeedControl() throws { // Given: load try syncController.loadVideoFile(testVideoFile) // When: Set speed to 2x // âš¡ 2 syncController.playbackSpeed = 2.0 // ğŸ® syncController.play() // ğŸ“Š let startTime = syncController.currentTime // â±ï¸ 0.5seconds (actual) Thread.sleep(forTimeInterval: 0.5) // ğŸ“Š let endTime = syncController.currentTime // Then: Should advance approximately 1 second (0.5s * 2x speed) // ğŸ“Š and let elapsed = endTime - startTime // âš¡ 0.8seconds (2 1seconds) // ğŸ’¡ 0.8 ( 1seconds) XCTAssertGreaterThan(elapsed, 0.8, "Should advance faster at 2x speed") } /** * * @section _____________ âœ…: query * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * each normally Verify. * * * @section ________ ğŸ“Š * @endcode * front: * [Frame][Frame][Frame]...[ ] 25/30 (83%) * * getBufferStatus() Return: * [ *.front: BufferStatus( * current: 25, * maximum: 30, * fillPercentage: 0.83 *) * ] * @endcode * * @test testBufferStatus * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> * - <b>When:</b> getBufferStatus() * - <b>Then:</b> each Return * @endcode */ func testBufferStatus() throws { // Given: load try syncController.loadVideoFile(testVideoFile) syncController.play() // â±ï¸ 0.5seconds () Thread.sleep(forTimeInterval: 0.5) // When: query let status = syncController.getBufferStatus() // Then: Verify // ğŸ“¦ XCTAssertFalse(status.isEmpty) // ğŸ“Š each Verify for (position, bufferStatus) in status { // ğŸ“¦ 1 frame XCTAssertGreaterThan( bufferStatus.current, 0, "Channel \(position.displayName) should have buffered frames") // ğŸ“Š 0.0 ~ 1.0 XCTAssertLessThanOrEqual(bufferStatus.fillPercentage, 1.0) } } /** * * @section ___________ âœ…: * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ * Verify. * * * @section _________ ğŸ”„ * @endcode *: * [â—â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•] 0.0seconds / 10.0seconds * â†“ play() * [â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â—â•â•â•] 8.5seconds / 10.0seconds * â†“ () * [â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â—] 10.0seconds / 10.0seconds * â†“ () *.stopped (currentTime = 10.0, position = 1.0) * @endcode * * â±ï¸ Polling: * @endcode * while playbackState ==.playing { * Thread.sleep(0.1seconds) * elapsed += 0.1seconds * if elapsed > timeout { break } * } * @endcode * * @test testPlayToEnd * @brief ğŸ“ Given-When-Then: * * @details * * @section given_when_then___ ğŸ“ Given-When-Then * @endcode * - <b>Given:</b> 10seconds load * - <b>When:</b>, * - <b>Then:</b>, currentTime = duration * @endcode */ func testPlayToEnd() throws { // Given: Short video // ğŸ¬ 10seconds load try syncController.loadVideoFile(testVideoFile) // When: Play to end // ğŸ® syncController.play() // Wait for playback to complete // â±ï¸ (duration + 2seconds) let timeout = syncController.duration + 2.0 // â±ï¸ and var elapsed: TimeInterval = 0.0 // â±ï¸ Confirm (0.1seconds Confirm) let checkInterval: TimeInterval = 0.1 // ğŸ”„ (Polling) while syncController.playbackState ==.playing && elapsed < timeout { // 0.1seconds Thread.sleep(forTimeInterval: checkInterval) // and elapsed += checkInterval } // Then: Should stop at end // ğŸ®.stopped () XCTAssertEqual(syncController.playbackState,.stopped) // â±ï¸ = duration () XCTAssertEqual(syncController.currentTime, syncController.duration) // ğŸ“ = 1.0 (100%) XCTAssertEqual(syncController.playbackPosition, 1.0) } } 